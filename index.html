<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SynthBoarders - Rhythm Typing Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Creepster&display=swap" rel="stylesheet">
    <script src="enemy_movement.js"></script>
    <script src="enemy_damage.js"></script>
    <script src="muzzle_flash.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            background-color: #000;
            color: #fff;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }
        #overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: space-between;
            z-index: 10;
            pointer-events: none;
        }
        
        /* Three main sections of the overlay */
        .overlay-section {
            display: flex;
            flex-direction: column;
            padding: 20px;
            width: 33.33%;
            box-sizing: border-box;
        }
        
        /* Left section - Character */
        #left-section {
            align-items: flex-start;
            justify-content: center;
        }
        
        #character-info {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ff00;
            border-radius: 10px;
            padding: 15px;
            margin-top: 50px;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
        }
        
        /* Middle section - Typing */
        #middle-section {
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        
        #typing-container {
            margin-bottom: 100px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px 40px;
            border-radius: 10px;
            border: 1px solid #00ffff;
            min-width: 300px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        #target {
            font-size: 32px;
            font-weight: bold;
            color: #00ff00;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
        }
        
        #input {
            font-size: 28px;
            color: white;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.7);
        }
        
        /* Right section - Enemies/Info */
        #right-section {
            align-items: flex-end;
            justify-content: center;
        }
        
        #game-info {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ff00;
            border-radius: 10px;
            padding: 15px;
            margin-top: 50px;
            text-align: right;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
        }
        
        /* Track info and lyrics display */
        #trackInfo {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            z-index: 20;
            text-shadow: 0 0 10px #00ffff;
        }
        
        #lyricsDisplay {
            position: absolute;
            bottom: 50px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 24px;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 20;
            text-shadow: 0 0 15px #00ffff;
        }
        
        /* Lyric Success/Fail Indicator */
        #lyricIndicator {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            position: absolute;
            top: 35%;
            left: 50%;
            transform: translate(-50%, -100%);
            width: 80%;
            max-width: 600px;
            margin: 0 auto;
            opacity: 0;
            z-index: 20;
            text-shadow: 0 0 15px;
        }
        
        @keyframes float-up-fade-out {
            0% {
                transform: translate(-50%, -100%);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -200%);
                opacity: 0;
            }
        }
        
        .float-fade {
            animation: float-up-fade-out 1.5s ease-out forwards;
        }
        
        /* Get Ready message styling */
        #get-ready-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
            z-index: 100;
            display: none;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
        }
        
        /* Battle Won message styling */
        .battle-won {
            color: #ffdd00 !important; /* Gold color for victory */
            text-shadow: 0 0 10px #ffaa00, 0 0 20px #ff8800, 0 0 30px #ff6600 !important;
            font-size: 3.5rem !important;
            letter-spacing: 2px;
            animation: battle-won-pulse 1.5s infinite !important;
        }
        
        @keyframes battle-won-pulse {
            0% { transform: translate(-50%, -50%) scale(0.95); opacity: 0.7; }
            50% { transform: translate(-50%, -50%) scale(1.05); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0.95); opacity: 0.7; }
        }
        
        /* Menu styles */
        .menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
        }
        
        .menuTitle {
            font-size: 48px;
            margin-bottom: 30px;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00;
            letter-spacing: 3px;
        }
        
        #gameTitle {
            text-align: center;
            margin-bottom: 20px;
        }
        
        #titleTop {
            font-family: 'Orbitron', sans-serif;
            font-size: 54px;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #00ffff;
        }
        
        #titleBottom {
            font-family: 'Creepster', sans-serif;
            font-style: italic;
            font-size: 42px;
            color: #00ffcc;
            text-shadow: 0 0 10px #00ffcc, 0 0 15px #ff00ff;
        }
        
        .menuButton, #startButton {
            margin: 10px;
            padding: 15px 30px;
            font-size: 24px;
            background: #003300;
            color: white;
            border: 2px solid #00ff00;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 2px;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        
        .menuButton:hover, #startButton:hover {
            background: #00cc00;
            transform: translateY(-3px);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
        }
        
        /* Animation classes */
        .shake {
            animation: shake 0.5s;
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }
            20%, 40%, 60%, 80% { transform: translateX(10px); }
            100% { transform: translateX(0); }
        }
        
        /* Splash screen overlay */
        #splashOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        #splashLogo {
            font-family: 'Orbitron', sans-serif;
            font-size: 72px;
            color: #ff00ff;
            text-shadow: 0 0 15px #ff00ff, 0 0 30px #00ffff;
            margin-bottom: 50px;
            text-align: center;
        }
        
        .splashTitle {
            font-family: 'Orbitron', sans-serif;
            font-size: 72px;
            color: #ff00ff;
            text-shadow: 0 0 15px #ff00ff, 0 0 30px #00ffff;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .splashSubtitle {
            font-family: 'Creepster', sans-serif;
            font-style: italic;
            font-size: 48px;
            color: #00ffcc;
            text-shadow: 0 0 10px #00ffcc, 0 0 15px #ff00ff;
            margin-bottom: 50px;
            text-align: center;
        }
        
        #enterGameButton {
            padding: 20px 40px;
            font-size: 28px;
            background: linear-gradient(to right, #003366, #006699);
            color: white;
            border: 2px solid #00ffcc;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 15px #00ffcc;
        }
        
        #enterGameButton:hover {
            background: linear-gradient(to right, #004080, #0088cc);
            transform: scale(1.05);
            box-shadow: 0 0 25px #00ffcc;
        }
        
        /* Lyric indicator styles */
        .lyric-indicator {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
            opacity: 0;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00;
            transition: opacity 0.3s ease-in-out;
        }
        
        .particle {
            position: fixed; /* Using fixed to ensure they appear on screen */
            width: 5px;
            height: 5px;
            background: #ff00ff;
            box-shadow: 0 0 10px #ff00ff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 30;
            animation: particle-animation 0.8s ease-out forwards;
        }
        
        @keyframes particle-animation {
            0% {
                transform: scale(0.2) translate(0, 0);
                opacity: 1;
            }
            100% {
                transform: scale(1) translate(var(--x-move), var(--y-move));
                opacity: 0;
            }
        }
        
        .fade-out {
            animation: fade-out 1s;
        }
        
        @keyframes fade-out {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        /* Add vignette effect for failure */
        @keyframes red-vignette {
            0% { opacity: 0; }
            20% { opacity: 0.9; } 
            100% { opacity: 0; }
        }
        
        #vignette-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            background: radial-gradient(circle, transparent 30%, rgba(255, 30, 30, 0.98) 100%); 
            opacity: 0;
            display: block;
            transition: opacity 0.1s ease;
        }
        
        .red-vignette {
            display: block !important;
            animation: red-vignette 1.2s ease-in-out forwards;
        }
        
        /* Strong shake animation for word timeout */
        @keyframes strong-shake {
            0% { transform: translate(0, 0); }
            10% { transform: translate(-15px, -8px); }
            20% { transform: translate(15px, 8px); }
            30% { transform: translate(-15px, 5px); }
            40% { transform: translate(15px, -5px); }
            50% { transform: translate(-15px, 8px); }
            60% { transform: translate(15px, -8px); }
            70% { transform: translate(-8px, 5px); }
            80% { transform: translate(8px, -5px); }
            90% { transform: translate(-4px, 2px); }
            100% { transform: translate(0, 0); }
        }
        
        .strong-shake {
            animation: strong-shake 0.6s ease-in-out;
        }
    </style>
</head>
<body>
    <!-- Main Canvas for Three.js -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- Vignette overlay for failure effect -->
    <div id="vignette-overlay"></div>
    
    <!-- Audio element for background music -->
    <audio id="audioElement" preload="auto"></audio>
    
    <!-- Game container -->
    <div id="container"></div>
    
    <!-- UI overlay container for game UI elements -->
    <div id="ui-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1000;">
        <!-- Enemy health bar (placed directly in HTML) -->
        <div id="static-enemy-health-container" style="position: fixed !important; top: 235px !important; right: 20px !important; width: 250px; z-index: 9999 !important; pointer-events: none; opacity: 0; transition: opacity 0.5s ease-in-out;">
            <div style="color: #fff; font-family: 'Orbitron', sans-serif; font-size: 14px; text-shadow: 0 0 5px rgba(0, 255, 255, 0.8); margin-bottom: 5px; text-align: right;">
                ENEMY: <span id="static-enemy-health-value">1000</span> / 1000
            </div>
            <div style="width: 250px; height: 20px; background-color: rgba(51, 51, 51, 0.8); border: 2px solid #00ffff; border-radius: 4px; box-shadow: 0 0 10px rgba(0, 255, 255, 0.5); overflow: hidden;">
                <div id="static-enemy-health-fill" style="width: 100%; height: 100%; background-color: #ff3333; transition: width 0.3s ease-out;"></div>
            </div>
        </div>
    </div>
    
    <!-- Game Info Overlay -->
    <div id="trackInfo">
        <span id="trackName">No Track Selected</span>
    </div>
    
    <!-- Splash Screen Overlay -->
    <div id="splashOverlay">
        <div id="splashLogo">
            <div class="splashTitle">Synthpocalypse Now!</div>
            <div class="splashSubtitle">War of Words</div>
        </div>
        <button id="enterGameButton">Enable Music & Enter Game</button>
    </div>
    
    <!-- Lyrics Display -->
    <div id="lyricsDisplay"></div>
    
    <!-- Lyric Success/Fail Indicator -->
    <div id="lyricIndicator"></div>
    
    <!-- Get Ready Message -->
    <div id="get-ready-message">
        Get Ready...
    </div>
    
    <!-- Three-Section Overlay -->
    <div id="overlay">
        <!-- Left Section - Character -->
        <div id="left-section" class="overlay-section">
            <div id="character-info">
                <h3>Character</h3>
                <p>Level: <span id="character-level">1</span></p>
                <p>Speed: <span id="character-speed">Normal</span></p>
                <p>Score: <span id="character-score">0</span></p>
            </div>
        </div>
        
        <!-- Middle Section - Typing -->
        <div id="middle-section" class="overlay-section">
            <div id="typing-container">
                <div id="target"></div>
                <div id="input"></div>
            </div>
        </div>
        
        <!-- Right Section - Enemies/Info -->
        <div id="right-section" class="overlay-section">
            <div id="game-info">
                <h3>Game Info</h3>
                <p>Current Track: <span id="current-track">None</span></p>
                <p>Accuracy: <span id="accuracy">0%</span></p>
                <p>Targets Hit: <span id="targets-hit">0</span></p>
            </div>
        </div>
    </div>
    
    <!-- Main Menu -->
    <div id="mainMenu" class="menu" style="display: none;">
        <div id="gameTitle">
            <div id="titleTop">Synthpocalypse Now!</div>
            <div id="titleBottom">War of Words</div>
        </div>
        <button id="startButton">Start Game</button>
    </div>
    
    <!-- Pause Menu (Initially Hidden) -->
    <div id="pauseMenu" class="menu" style="display: none;">
        <h1 class="menuTitle">Game Paused</h1>
        <button id="resumeButton" class="menuButton">Resume</button>
        <button id="restartLevelButton" class="menuButton">Restart Battle</button>
        <button id="restartCampaignButton" class="menuButton">Restart Campaign</button>
        <button id="quitButton" class="menuButton">Quit to Main Menu</button>
    </div>
    
    <!-- Debug Info -->
    <div id="debug-info" style="position: absolute; bottom: 10px; left: 10px; color: #00ff00; font-size: 12px; z-index: 100;"></div>
    
    <!-- Import Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Track list
        const tracks = [
            {
                name: "March at Dawn",
                src: "assets/music/1 March at Dawn.ogg",
                lrc: "assets/lyrics/1 March at Dawn.lrc",
                beats: [0, 3.5, 7.0, 10.5, 14.0] // First few beats for testing
            }
            // Note: Second track commented out until asset is available
            /*
            {
                name: "Doubts Dismissed",
                src: "assets/music/2 Doubts Dismissed.ogg",
                lrc: "assets/lyrics/1 March at Dawn.lrc", // Reuse the lyrics for now
                beats: [0, 3.2, 6.4, 9.6, 12.8] // Sample beats
            }
            */
        ];
        
        // Target lyrics for March at Dawn - using more challenging multi-word phrases
        const marchAtDawnLyrics = [
            "PROUD DAY",
            "HONOR LAY",
            "CALL TO ARMS",
            "UNKNOWN HARMS",
            "SOARING HIGHS",
            "STORMY SIGH",
            "DAWNING LIGHT",
            "INTO THE FIGHT",
            "RIGHTEOUS ZEAL",
            "WHOLE ORDEAL",
            "RIGHTEOUS ZEAL",
            "WHOLE ORDEAL",
            "ARMORS SHEEN",
            "ONCE HAD SEEMED",
            "CONVICTION REIGNED",
            "HAS BEEN STAINED",
            "FOREBODING SOUND",
            "MY FEARS ABOUND",
            "DAWNING LIGHT",
            "INTO THE FIGHT",
            "RIGHTEOUS ZEAL",
            "WHOLE ORDEAL",
            "WARS EMBRACE",
            "TRUTHS DIM TRACE",
            "GLORYS SAKE",
            "MOUNTAINS QUAKE",
            "DAWNING LIGHT",
            "INTO THE FIGHT",
            "RIGHTEOUS ZEAL",
            "WHOLE ORDEAL",
            "SOUL NOW WEEPS",
            "FADES INTO NIGHT",
            "HARSH DAYLIGHT",
            "PATH GROWS STEEP",
            "SOUL NOW WEEPS",
            "MY SOUL NOW WEEPS"
        ];
        
        // Official embedded lyrics from the LRC file
        const officialLyrics = `[ti:1 March at Dawn]
[ar:Vanitas]
[al:Synth-pocalypse Now!]
[au:Matthew Walker]
[by:Matthew Walker]
[la:EN]
[re:LRCgenerator.com]
[ve:4.00]

[00:11.36]IN THE BLAZE OF YOUTH'S PROUD DAY,
[00:16.04]MARCHING FORTH WHERE HONOR LAY,
[00:20.45]BELIEF AS CLEAR AS A CALL TO ARMS,
[00:25.12]THE SOUND OF GLORY, IN THE FACE OF UNKNOWN HARMS.

[00:33.95]YET BENEATH THE HYMNS OF SOARING HIGHS,
[00:39.13]HIDE WHISPERS OF A STORMY SIGH.

[00:44.17]LOSING SIGHT IN THE DAWNING LIGHT,
[00:48.28]I CHARGE AHEAD, INTO THE FIGHT,
[00:53.35]HEART ABLAZE WITH RIGHTEOUS ZEAL,
[00:57.64]BLINDED TO THE WHOLE ORDEAL.

[01:21.70]HEART ABLAZE WITH RIGHTEOUS ZEAL,
[01:26.35]BLINDED TO THE WHOLE ORDEAL.

[01:40.39]FIRST CRACKS IN THE ARMOR'S SHEEN,
[01:44.58]NOT ALL IS AS IT ONCE HAD SEEMED,
[01:49.38]SEEDS OF DOUBT, WHERE CONVICTION REIGNED,
[01:53.90]BY THE BLOOD OF COUNTLESS, FAITH HAS BEEN STAINED.

[02:28.64]FIRST CRACKS, A FOREBODING SOUND,
[02:35.65]AS THE GROUND BENEATH SHAKES, MY FEARS ABOUND.

[02:44.15]LOSING SIGHT IN THE DAWNING LIGHT,
[02:47.71]AND I, I CHARGE AHEAD, INTO THE FIGHT,
[02:53.46]HEART ABLAZE WITH RIGHTEOUS ZEAL,
[02:57.38]BLINDED TO THE WHOLE ORDEAL.

[03:22.69]THROUGH THE FOG OF WAR'S EMBRACE,
[03:27.15]SEARCHING FOR THE TRUTH'S DIM TRACE,
[03:31.85]SIRENS CALL NOT FOR GLORY'S SAKE,
[03:36.51]I RETURN TO HELL, AS THE MOUNTAINS QUAKE.
[03:49.78]LOSING SIGHT IN THE DAWNING LIGHT,
[03:53.21]AND I, I CHARGE AHEAD, INTO THE FIGHT,
[03:58.99]HEART ABLAZE WITH RIGHTEOUS ZEAL,
[04:03.11]BLINDED TO THE WHOLE ORDEAL.

[04:09.01]IN THE SILENCE, MY SOUL NOW WEEPS.

[04:37.76]AS THE DAWN FADES INTO NIGHT,
[04:42.08]LESSONS LEARNED IN THE HARSH DAYLIGHT,
[04:46.79]WITH EACH STEP, THE PATH GROWS STEEP,
[04:51.72]IN THE SILENCE, MY SOUL NOW WEEPS.

[05:06.90]IN THE SILENCE, MY SOUL NOW WEEPS.`;
        
        // Current level tracking
        let currentLevel = 0; // Start at level 1 (index 0)
        const audioElement = document.getElementById('audioElement');
        
        // Beat tracking variables
        let currentBeats = [];
        let nextBeatIndex = 0;
        
        // Lyrics tracking variables
        let currentLyrics = [];
        let nextLyricIndex = 0;
        
        // Game state tracking
        let gameStarted = false;    // Whether the game has been started (vs menu)
        let inGame = false;         // Whether we're in the gameplay section
        let gameplayActive = false; // Whether active gameplay mechanics should run
        let currentTargetWord = "";
        let currentPlayerInput = "";
        let currentLyricIndex = -1;
        let timeWindow = 4; // Default 4 seconds to type each lyric
        let currentTimeWindow = 4; // Variable time window that adapts to lyrics
        let targetStartTime = null;
        let justCompletedTarget = false; // Flag to track if we just completed a target
        let inGetReadyPhase = false; // Whether we're in the "Get Ready" phase
        let firstLyricsPlayed = false; // Whether the first lyrics have been played
        let earlyBulletStopTime = 0; // Time when bullets should stop spawning (3 seconds before next lyric)
        
        // Initialize Three.js scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000033); // Dark blue background
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // Create a blue grid plane for the "ground"
        const gridGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
        const gridMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, 
            wireframe: true, 
            transparent: true,
            opacity: 0.3 
        });
        const grid = new THREE.Mesh(gridGeometry, gridMaterial);
        grid.rotation.x = -Math.PI / 2; // Rotate to horizontal
        scene.add(grid);
        
        // Add some decorative elements to the scene
        // Sun/moon in the distance
        const sunGeometry = new THREE.SphereGeometry(50, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff }); // Neon magenta
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(0, 100, -500);
        scene.add(sun);
        
        // Add some mountains in the background
        function createMountain(x, height, z) {
            const mountainGeometry = new THREE.ConeGeometry(height/2, height, 4);
            const mountainMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x880088,
                wireframe: true
            });
            const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
            mountain.position.set(x, height/2, z);
            scene.add(mountain);
        }
        
        // Create several mountains
        createMountain(-200, 100, -400);
        createMountain(-100, 150, -350);
        createMountain(150, 120, -380);
        createMountain(250, 90, -420);
        
        // Create a texture loader for loading sprite images
        const textureLoader = new THREE.TextureLoader();
        
        // Create a CHARACTER using colored THREE.js geometry with multiple parts
        // This will be more visible and better match the synthwave aesthetic
        let character = new THREE.Group(); // Create a group to hold character parts
        
        // Body
        const bodyGeometry = new THREE.BoxGeometry(5, 8, 2);
        const bodyMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff00ff, // Neon magenta
            wireframe: false
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 2; // Move up to make room for legs
        body.rotation.z = -0.05; // Slight tilt to look more dynamic
        character.add(body);
        
        // Head
        const headGeometry = new THREE.BoxGeometry(4, 4, 2);
        const headMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff00ff, // Neon magenta
            wireframe: false
        });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 8; // Position at top of body
        head.rotation.z = 0.1; // Slight head tilt to look more dynamic
        character.add(head);
        
        // Visor - make this a contrasting color and facing the enemy (to the right)
        const visorGeometry = new THREE.BoxGeometry(2.1, 1, 3); // Oriented to face right
        const visorMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, // Cyan
            wireframe: false
        });
        const visor = new THREE.Mesh(visorGeometry, visorMaterial);
        visor.position.y = 8; // Center of head
        visor.position.x = 1.5; // Placed on right side of head when facing right (toward negative X)
        character.add(visor);
        
        // Arms
        const upperArmGeometry = new THREE.BoxGeometry(1.5, 4, 1.5);
        const lowerArmGeometry = new THREE.BoxGeometry(1.5, 4, 1.5);
        const armMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff00ff, // Neon magenta
            wireframe: false
        });
        
        // Left arm (upper)
        const leftUpperArm = new THREE.Mesh(upperArmGeometry, armMaterial);
        leftUpperArm.position.x = -3.5; // Left of body
        leftUpperArm.position.y = 3.5; // Shoulder height
        leftUpperArm.rotation.z = -0.3; // Slight downward angle
        character.add(leftUpperArm);
        
        // Left arm (lower) - positioned to hold front of gun
        const leftLowerArm = new THREE.Mesh(lowerArmGeometry, armMaterial);
        leftLowerArm.position.x = -1.5; // Moved toward center
        leftLowerArm.position.y = 2; // Position to hold gun
        leftLowerArm.position.z = 1; // Forward
        leftLowerArm.rotation.z = 0.1; // Adjusted angle
        leftLowerArm.rotation.y = -0.4; // Rotated inward 
        character.add(leftLowerArm);
        
        // Left hand - positioned to hold front of gun
        const leftHandGeometry = new THREE.BoxGeometry(1, 1.5, 1.5);
        const leftHandMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff00ff, // Neon magenta
            wireframe: false
        });
        const leftHand = new THREE.Mesh(leftHandGeometry, leftHandMaterial);
        leftHand.position.x = 0; // Center (holding front of gun)
        leftHand.position.y = 2; // Aligned with weapon
        leftHand.position.z = 1.8; // Forward of body
        leftHand.rotation.y = -0.3; // Angled to grip weapon
        character.add(leftHand);
        
        // Right arm (upper) - in shooting position
        const rightUpperArm = new THREE.Mesh(upperArmGeometry, armMaterial);
        rightUpperArm.position.x = 3.5; // Right of body
        rightUpperArm.position.y = 3.5; // Shoulder height
        rightUpperArm.position.z = 0.5; // Slightly forward
        rightUpperArm.rotation.z = 0.2; // Raised slightly
        character.add(rightUpperArm);
        
        // Right arm (lower) - extended holding weapon
        const rightLowerArm = new THREE.Mesh(lowerArmGeometry, armMaterial);
        rightLowerArm.position.x = 4.5; // Closer to center
        rightLowerArm.position.y = 2.5; // Lower 
        rightLowerArm.position.z = 1; // More forward
        rightLowerArm.rotation.z = -0.1; // Slightly angled to hold weapon
        rightLowerArm.rotation.y = 0.4; // Rotated inward toward body
        character.add(rightLowerArm);
        
        // Hand
        const handGeometry = new THREE.BoxGeometry(1, 1.5, 1.5);
        const handMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff00ff, // Neon magenta
            wireframe: false
        });
        const hand = new THREE.Mesh(handGeometry, handMaterial);
        hand.position.x = 3; // Moved toward center of body
        hand.position.y = 2; // Aligned with arm
        hand.position.z = 1.5; // Forward
        hand.rotation.y = 0.3; // Angled to hold weapon
        character.add(hand);
        
        // Main weapon body
        const weaponBodyGeometry = new THREE.BoxGeometry(5, 1.2, 1.5);
        const weaponMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x555555, // Gray
            wireframe: false
        });
        const weaponBody = new THREE.Mesh(weaponBodyGeometry, weaponMaterial);
        weaponBody.position.x = 3; // Positioned across the chest
        weaponBody.position.y = 2; // Center height
        weaponBody.position.z = 2; // In front of the body
        weaponBody.rotation.y = 0.3; // Angled slightly
        character.add(weaponBody);
        
        // Weapon grip (where hand holds)
        const weaponGripGeometry = new THREE.BoxGeometry(1, 2, 1);
        const weaponGripMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x333333, // Darker gray
            wireframe: false
        });
        const weaponGrip = new THREE.Mesh(weaponGripGeometry, weaponGripMaterial);
        weaponGrip.position.x = 3; // At the hand
        weaponGrip.position.y = 1; // Below main body
        weaponGrip.position.z = 2; // In front of body
        weaponGrip.rotation.y = 0.3; // Angled same as body
        character.add(weaponGrip);
        
        // Weapon top rail
        const weaponTopGeometry = new THREE.BoxGeometry(4, 0.5, 1);
        const weaponTopMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x222222, // Very dark gray
            wireframe: false
        });
        const weaponTop = new THREE.Mesh(weaponTopGeometry, weaponTopMaterial);
        weaponTop.position.x = 3; // Align with main body
        weaponTop.position.y = 2.5; // Top of weapon
        weaponTop.position.z = 2; // In front of body
        weaponTop.rotation.y = 0.3; // Angled same as body
        character.add(weaponTop);
        
        // Weapon barrel
        const weaponBarrelGeometry = new THREE.BoxGeometry(3, 0.8, 0.8);
        const weaponBarrelMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x333333, // Darker gray
            wireframe: false
        });
        const weaponBarrel = new THREE.Mesh(weaponBarrelGeometry, weaponBarrelMaterial);
        weaponBarrel.position.x = 5.5; // Extending right from body
        weaponBarrel.position.y = 2; // Aligned with body
        weaponBarrel.position.z = 2; // In front of body
        weaponBarrel.rotation.y = 0.3; // Angled same as body
        character.add(weaponBarrel);
        
        // Weapon energy core (glowing part)
        const weaponCoreGeometry = new THREE.SphereGeometry(1, 8, 8);
        const weaponCoreMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, // Cyan
            wireframe: false
        });
        const weaponCore = new THREE.Mesh(weaponCoreGeometry, weaponCoreMaterial);
        weaponCore.position.x = 3; // Middle of gun
        weaponCore.position.y = 1.6; // Bottom of main body
        weaponCore.position.z = 2.1; // Slightly forward from gun body
        weaponCore.rotation.y = 0.3; // Angled same as body
        character.add(weaponCore);
        
        // Weapon energy glow (muzzle)
        const weaponGlowGeometry = new THREE.BoxGeometry(0.6, 0.6, 1.2);
        const weaponGlowMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, // Cyan
            wireframe: false
        });
        const weaponGlow = new THREE.Mesh(weaponGlowGeometry, weaponGlowMaterial);
        weaponGlow.position.x = 7; // End of barrel
        weaponGlow.position.y = 2; // Align with barrel
        weaponGlow.position.z = 2; // In front of body
        weaponGlow.rotation.y = 0.3; // Angled same as body
        character.add(weaponGlow);
        
        // Store weapon glow reference for muzzle flash effects
        character.weaponGlow = weaponGlow;
        
        // Initialize the muzzle flash system
        if (window.MuzzleFlash && typeof window.MuzzleFlash.init === 'function') {
            window.MuzzleFlash.init(scene, weaponGlow);
        }
        
        // Legs
        const upperLegGeometry = new THREE.BoxGeometry(2, 4, 2);
        const legMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff00ff, // Neon magenta
            wireframe: false
        });
        
        // Left leg (upper)
        const leftUpperLeg = new THREE.Mesh(upperLegGeometry, legMaterial);
        leftUpperLeg.position.x = -1.5; // Left side
        leftUpperLeg.position.y = -3; // Below body
        leftUpperLeg.rotation.z = 0.05; // Slight angle
        character.add(leftUpperLeg);
        
        // Left leg (lower)
        const lowerLegGeometry = new THREE.BoxGeometry(2, 4, 2);
        const leftLowerLeg = new THREE.Mesh(lowerLegGeometry, legMaterial);
        leftLowerLeg.position.x = -1.5; // Left side
        leftLowerLeg.position.y = -6.5; // Below upper leg
        character.add(leftLowerLeg);
        
        // Right leg (upper) - when facing negative X
        const rightUpperLeg = new THREE.Mesh(upperLegGeometry, legMaterial);
        rightUpperLeg.position.x = 1.5; // Right side
        rightUpperLeg.position.y = -3; // Below body
        rightUpperLeg.rotation.z = -0.1; // Slight angle outward
        character.add(rightUpperLeg);
        
        // Right leg (lower)
        const rightLowerLeg = new THREE.Mesh(lowerLegGeometry, legMaterial);
        rightLowerLeg.position.x = 1.7; // Right side
        rightLowerLeg.position.y = -6.5; // Below upper leg
        character.add(rightLowerLeg);
        
        // Position the character
        character.position.set(-250, 2, 0); // Far left off-screen initially
        
        // Add a collision sphere for more accurate hit detection
        character.collisionRadius = 6; // Adjust based on character size
        
        // Character movement variables
        const characterMovement = {
            moveSpeed: 0.8,        // Base movement speed
            jumpSpeed: 1.2,        // Jump velocity
            gravity: 0.1,          // Gravity force
            yVelocity: 0,          // Current vertical velocity
            isJumping: false,      // Whether character is currently jumping
            isCrouching: false,    // Whether character is currently crouching
            keys: {                // Keyboard state tracking
                left: false,
                right: false,
                up: false,
                down: false
            },
            minX: -45,             // Left boundary
            maxX: -10,             // Right boundary
            baseY: 2,              // Default y position (standing)
            crouchY: 0,            // Y position when crouching
            maxY: 10,              // Maximum jump height
            minY: -4               // Minimum position (for platform feel)
        };
        
        scene.add(character);
        console.log("Enhanced character created with improved weapon and posing");
        
        let characterAnimTime = 0;
        
        // Create an ENEMY model using similar structure but different aesthetics
        let enemy = new THREE.Group(); // Create a group to hold enemy parts
        
        // Enemy Body - wider, more threatening
        const enemyBodyGeometry = new THREE.BoxGeometry(6, 7, 2);
        const enemyMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff3300, // Bright orange-red
            wireframe: false
        });
        const enemyBody = new THREE.Mesh(enemyBodyGeometry, enemyMaterial);
        enemyBody.position.y = 2; 
        enemyBody.rotation.z = -0.05; // Slight tilt mirrored from player
        enemy.add(enemyBody);
        
        // Enemy Head - angular and menacing
        const enemyHeadGeometry = new THREE.BoxGeometry(5, 3, 2.5);
        const enemyHeadMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff3300, // Bright orange-red
            wireframe: false
        });
        const enemyHead = new THREE.Mesh(enemyHeadGeometry, enemyHeadMaterial);
        enemyHead.position.y = 7; // Position at top of body
        enemy.add(enemyHead);
        
        // Enemy Visor - make this more aggressive looking
        const enemyVisorGeometry = new THREE.BoxGeometry(4, 0.8, 3); // Wider, more menacing
        const enemyVisorMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff0000, // Bright red
            wireframe: false
        });
        const enemyVisor = new THREE.Mesh(enemyVisorGeometry, enemyVisorMaterial);
        enemyVisor.position.y = 7; // Center of head
        enemyVisor.position.x = -1.5; // Left side of head when facing right (toward negative X)
        enemy.add(enemyVisor);
        
        // Enemy Arms
        const enemyUpperArmGeometry = new THREE.BoxGeometry(2, 4, 2);
        const enemyArmMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff3300, // Bright orange-red
            wireframe: false
        });
        
        // Right arm (upper) - this is on the right side when facing toward negative X
        const enemyRightUpperArm = new THREE.Mesh(enemyUpperArmGeometry, enemyArmMaterial);
        enemyRightUpperArm.position.x = -4; // Right of body
        enemyRightUpperArm.position.y = 3.5; // Shoulder height
        enemyRightUpperArm.rotation.z = -0.7; // Angled to hold weapon
        enemy.add(enemyRightUpperArm);
        
        // Right arm (lower)
        const enemyLowerArmGeometry = new THREE.BoxGeometry(2, 4, 2);
        const enemyRightLowerArm = new THREE.Mesh(enemyLowerArmGeometry, enemyArmMaterial);
        enemyRightLowerArm.position.x = -5; // Further right and forward
        enemyRightLowerArm.position.y = 2; // Position to hold weapon
        enemyRightLowerArm.rotation.z = 0.3; // Bent at elbow to hold gun
        enemy.add(enemyRightLowerArm);
        
        // Left arm (upper) - this is on the left side when facing toward negative X
        const enemyLeftUpperArm = new THREE.Mesh(enemyUpperArmGeometry, enemyArmMaterial);
        enemyLeftUpperArm.position.x = 3; // Left of body
        enemyLeftUpperArm.position.y = 3.5; // Shoulder height
        enemyLeftUpperArm.rotation.z = 0.6; // Angled out to hold weapon
        enemy.add(enemyLeftUpperArm);
        
        // Left arm (lower)
        const enemyLeftLowerArm = new THREE.Mesh(enemyLowerArmGeometry, enemyArmMaterial);
        enemyLeftLowerArm.position.x = 3; // Positioned to support weapon
        enemyLeftLowerArm.position.y = 1.5; // Lower to reach across body
        enemyLeftLowerArm.rotation.z = -0.8; // Angled to support gun from below
        enemy.add(enemyLeftLowerArm);
        
        // Legs
        const enemyUpperLegGeometry = new THREE.BoxGeometry(2.5, 4, 2.5);
        const enemyLegMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff3300, // Bright orange-red
            wireframe: false
        });
        
        // Right leg (upper) - when facing negative X
        const enemyRightUpperLeg = new THREE.Mesh(enemyUpperLegGeometry, enemyLegMaterial);
        enemyRightUpperLeg.position.x = -2; // Right side
        enemyRightUpperLeg.position.y = -3; // Below body
        enemy.add(enemyRightUpperLeg);
        
        // Right leg (lower)
        const enemyLowerLegGeometry = new THREE.BoxGeometry(2.5, 4, 2.5);
        const enemyRightLowerLeg = new THREE.Mesh(enemyLowerLegGeometry, enemyLegMaterial);
        enemyRightLowerLeg.position.x = -2; // Right side
        enemyRightLowerLeg.position.y = -6.5; // Below upper leg
        enemy.add(enemyRightLowerLeg);
        
        // Left leg (upper) - when facing negative X
        const enemyLeftUpperLeg = new THREE.Mesh(enemyUpperLegGeometry, enemyLegMaterial);
        enemyLeftUpperLeg.position.x = 2; // Left side
        enemyLeftUpperLeg.position.y = -3; // Below body
        enemy.add(enemyLeftUpperLeg);
        
        // Left leg (lower)
        const enemyLeftLowerLeg = new THREE.Mesh(enemyLowerLegGeometry, enemyLegMaterial);
        enemyLeftLowerLeg.position.x = 2; // Left side
        enemyLeftLowerLeg.position.y = -6.5; // Below upper leg
        enemy.add(enemyLeftLowerLeg);
        
        // Enemy weapon - laser cannon with contrasting color, positioned across body
        // Create a group for the weapon to add more details
        const enemyWeaponGroup = new THREE.Group();
        
        // Main weapon body
        const enemyWeaponGeometry = new THREE.BoxGeometry(8, 2, 2);
        const enemyWeaponMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ccff, // Bright cyan/blue for contrast with orange-red body
            wireframe: false
        });
        const enemyWeapon = new THREE.Mesh(enemyWeaponGeometry, enemyWeaponMaterial);
        enemyWeapon.position.x = 0; // Center of group
        enemyWeapon.position.y = 0; // Center of group
        enemyWeaponGroup.add(enemyWeapon);
        
        // Weapon barrel
        const enemyBarrelGeometry = new THREE.CylinderGeometry(0.6, 0.8, 4, 8);
        const enemyBarrelMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x0088cc, // Darker blue for barrel
            wireframe: false
        });
        const enemyBarrel = new THREE.Mesh(enemyBarrelGeometry, enemyBarrelMaterial);
        enemyBarrel.rotation.z = Math.PI / 2; // Rotate to point forward
        enemyBarrel.position.x = -6; // Extend from main weapon body
        enemyWeaponGroup.add(enemyBarrel);
        
        // Weapon sights
        const enemySightGeometry = new THREE.BoxGeometry(1, 0.8, 0.5);
        const enemySightMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x005588, // Darker blue
            wireframe: false
        });
        const enemySight = new THREE.Mesh(enemySightGeometry, enemySightMaterial);
        enemySight.position.y = 1; // Top of weapon
        enemySight.position.x = -1; // Near back of weapon
        enemyWeaponGroup.add(enemySight);
        
        // Weapon handle
        const enemyHandleGeometry = new THREE.BoxGeometry(0.8, 2, 0.8);
        const enemyHandleMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x004466, // Even darker blue
            wireframe: false
        });
        const enemyHandle = new THREE.Mesh(enemyHandleGeometry, enemyHandleMaterial);
        enemyHandle.position.y = -1.5; // Bottom of weapon
        enemyHandle.position.x = 1.5; // Back half of weapon
        enemyWeaponGroup.add(enemyHandle);
        
        // Weapon core - glowing part with contrasting color
        const enemyCoreGeometry = new THREE.SphereGeometry(1, 8, 8);
        const enemyCoreMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, // Brighter cyan
            wireframe: false
        });
        const enemyCore = new THREE.Mesh(enemyCoreGeometry, enemyCoreMaterial);
        enemyCore.position.x = -7; // End of barrel
        enemyCore.position.y = 0; // Center of barrel
        enemyWeaponGroup.add(enemyCore);
        
        // Position the entire weapon group
        enemyWeaponGroup.position.x = -2; // Position so it overlaps across the body
        enemyWeaponGroup.position.y = 3; // Move up to clear the body
        enemyWeaponGroup.position.z = 1.5; // Bring forward to be over the body
        enemyWeaponGroup.rotation.y = -Math.PI / 6; // Angle it slightly
        
        enemy.add(enemyWeaponGroup);
        
        // Adjust right arm to hold weapon higher
        enemyRightLowerArm.position.y = 3; // Higher to match weapon
        
        // Adjust left arm to hold weapon higher
        enemyLeftLowerArm.position.y = 2.5; // Higher to match weapon
        
        // Position the enemy
        enemy.position.set(250, 2, 0); // Far right off-screen initially
        enemy.rotation.y = 0; // No rotation needed as we've constructed it to face left
        
        // Add a collision sphere for hit detection
        enemy.collisionRadius = 7; // Slightly larger than player
        
        scene.add(enemy);
        console.log("Enemy created with menacing appearance");
        
        let enemyAnimTime = 0; // Animation time counter for enemy
        
        // Position camera
        camera.position.y = 10;
        camera.position.z = 50;
        camera.lookAt(0, 0, 0);
        
        // Bullet hell variables
        let bullets = [];
        let lastBulletTime = 0; // For periodic bullet spawning
        
        // Bullet class for bullet hell mechanics
        class Bullet {
            constructor(x, y, z) {
                // Add debug stack trace to see where bullets are being created from
                console.log("Bullet created at position: X:" + x + ", Y:" + y + ", Z:" + z);
                console.log("inGetReadyPhase:", inGetReadyPhase, "firstLyricsPlayed:", firstLyricsPlayed);
                console.trace("Bullet creation stack trace");
                
                this.geometry = new THREE.SphereGeometry(1.0, 16, 16); // Reduced from 3.0 to 1.0
                this.material = new THREE.MeshPhongMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.5,
                    specular: 0xffffff,
                    shininess: 30
                });
                this.mesh = new THREE.Mesh(this.geometry, this.material);
                this.mesh.position.set(x, y, z);
                
                // Create a custom trail geometry for a graceful taper from bullet to point
                // Use three segments to create a more shaped trail that tapers gracefully 
                const trailLength = 6;
                const trailSegments = 16;
                const radiusTop = 0.9;     // Slightly wider at bullet connection point
                const radiusBottom = 0.2;  // More pointed at the far end
                
                const trailGeometry = new THREE.CylinderGeometry(
                    radiusTop, radiusBottom, trailLength, trailSegments
                );
                
                // Create a custom displacement for vertices to make a more curved taper
                const positionAttribute = trailGeometry.getAttribute('position');
                for (let i = 0; i < positionAttribute.count; i++) {
                    const y = positionAttribute.getY(i);
                    
                    // Only modify non-cap vertices (exclude the very top and bottom caps)
                    if (y !== trailLength/2 && y !== -trailLength/2) {
                        // Get normalized position along trail (0 at bullet end, 1 at far end)
                        const normalizedPos = (trailLength/2 - y) / trailLength;
                        
                        // Create a curved taper using exponential falloff
                        // This makes it taper more quickly near the bullet
                        const taperedScale = Math.pow(1 - normalizedPos, 1.5);
                        
                        // Scale x and z coordinates to create the custom taper
                        const x = positionAttribute.getX(i);
                        const z = positionAttribute.getZ(i);
                        positionAttribute.setX(i, x * taperedScale);
                        positionAttribute.setZ(i, z * taperedScale);
                    }
                }
                
                // Update normals after modification
                trailGeometry.computeVertexNormals();
                
                this.trailMesh = new THREE.Mesh(
                    trailGeometry,
                    new THREE.MeshPhongMaterial({ 
                        color: 0xff5500, 
                        emissive: 0xff3300,
                        transparent: true, 
                        opacity: 0.9,
                        emissiveIntensity: 0.8
                    })
                );
                this.trailMesh.rotation.x = Math.PI / 2; // Rotate to point along Z-axis
                scene.add(this.trailMesh);
                
                // Add the bullet to the scene - this is crucial!
                scene.add(this.mesh);
                
                console.log(`Bullet created at position: X:${x}, Y:${y}, Z:${z}`);
            }
            
            update() {
                // Move bullet upward
                this.mesh.position.z += 0.4; // Doubled from 0.2
                
                // Update trail position to follow behind bullet
                this.trailMesh.position.copy(this.mesh.position);
                this.trailMesh.position.z -= 3.0; // Adjusted for the new custom trail shape
            }
            
            // Method to clean up properly
            remove() {
                scene.remove(this.mesh);
                scene.remove(this.trailMesh);
            }
        }
        
        // Add a point light to illuminate bullets better
        const pointLight = new THREE.PointLight(0xffffff, 1, 100);
        pointLight.position.set(0, 10, 10);
        scene.add(pointLight);
        
        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const verticalLaneX = [-2, 2]; // Left and right lanes for vertical bullets
        const horizontalLaneY = [0]; // Single lane at eye level for horizontal bullets (first level)
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate sun
            if (typeof sun !== 'undefined') {
                sun.rotation.y += 0.005;
            }
            
            // Move grid to create forward motion effect
            if (typeof grid !== 'undefined') {
                grid.position.z += 0.1;
                if (grid.position.z > 20) {
                    grid.position.z = 0;
                }
            }
            
            // Animate character
            if (character) {
                characterAnimTime += 0.03;
                
                // Character movement logic
                // Left/Right movement
                if (characterMovement.keys.left) {
                    character.position.x -= characterMovement.moveSpeed;
                    if (character.position.x < characterMovement.minX) {
                        character.position.x = characterMovement.minX;
                    }
                }
                if (characterMovement.keys.right) {
                    character.position.x += characterMovement.moveSpeed;
                    if (character.position.x > characterMovement.maxX) {
                        character.position.x = characterMovement.maxX;
                    }
                }
                
                // Jumping and gravity
                if (characterMovement.isJumping) {
                    // Apply velocity to position
                    character.position.y += characterMovement.yVelocity;
                    
                    // Apply gravity to velocity
                    characterMovement.yVelocity -= characterMovement.gravity;
                    
                    // Check if we've landed
                    if (character.position.y <= characterMovement.baseY) {
                        character.position.y = characterMovement.baseY;
                        characterMovement.yVelocity = 0;
                        characterMovement.isJumping = false;
                    }
                    
                    // Cap the maximum height
                    if (character.position.y > characterMovement.maxY) {
                        character.position.y = characterMovement.maxY;
                        characterMovement.yVelocity = 0; // Start falling
                    }
                } else if (characterMovement.isCrouching) {
                    // Smoothly transition to crouching position
                    character.position.y = characterMovement.crouchY;
                    
                    // Scale the character slightly to appear crouched
                    character.scale.y = 0.7;
                } else {
                    // Return to normal height when not crouching
                    character.position.y = characterMovement.baseY + Math.sin(characterAnimTime) * 0.3;
                    character.scale.y = 1.0;
                }
                
                // Rotate slightly for more dynamic appearance
                character.rotation.z = Math.sin(characterAnimTime * 0.2) * 0.03;
                
                // Lean into movement direction slightly
                if (characterMovement.keys.left) {
                    character.rotation.z = Math.max(character.rotation.z, 0.1);
                } else if (characterMovement.keys.right) {
                    character.rotation.z = Math.min(character.rotation.z, -0.1);
                }
                
                // Make the visor flash between colors
                if (character.children && character.children.length > 2) {
                    const visor = character.children[2];
                    if (visor && visor.material) {
                        // Flash between cyan and a bright blue
                        const flash = Math.sin(characterAnimTime * 3) > 0;
                        visor.material.color.set(flash ? 0x00ffff : 0x00aaff);
                    }
                }
                
                // Find weapon parts by their properties
                let weaponCore = null;
                let weaponGlow = null;
                
                // Look through all children for the weapon parts
                for (let i = 0; i < character.children.length; i++) {
                    const child = character.children[i];
                    if (!child || !child.material) continue;
                    
                    // Check material color and position to identify parts
                    if (child.material.color) {
                        // Cyan colored parts around z=2 (forward position)
                        const color = child.material.color;
                        const isCyan = color.g > 0.5 && color.b > 0.5 && color.r < 0.3;
                        
                        if (isCyan && child.position.z > 1.5) {
                            // Smaller one at the end of barrel is the glow
                            if (child.position.x > 6) {
                                weaponGlow = child;
                            }
                            // One in the middle of the gun is the core
                            else if (Math.abs(child.position.x - 3) < 1) {
                                weaponCore = child;
                            }
                        }
                    }
                }
                
                // Animate weapon core
                if (weaponCore && !character.justReset) {
                    const pulse = 0.6 + 0.4 * Math.sin(characterAnimTime * 4);
                    weaponCore.material.color.setRGB(0, pulse, pulse);
                }
                
                // Animate weapon glow
                if (weaponGlow && !character.justReset) {
                    const pulse = 0.5 + 0.5 * Math.sin(characterAnimTime * 6);
                    weaponGlow.material.color.setRGB(0, pulse, pulse);
                    
                    const glowPulse = 1 + Math.sin(characterAnimTime * 6) * 0.2;
                    weaponGlow.scale.set(glowPulse, glowPulse, glowPulse);
                }
                
                // Update muzzle flash animation if it exists
                if (window.MuzzleFlash && typeof window.MuzzleFlash.update === 'function') {
                    window.MuzzleFlash.update();
                }
            }
            
            // Animate enemy
            if (enemy) {
                enemyAnimTime += 0.03;
                
                // Bob the enemy up and down slightly
                enemy.position.y = 2 + Math.sin(enemyAnimTime * 0.7) * 0.4;
                
                // Pulse the enemy core
                enemy.children.forEach(part => {
                    if (part.geometry && part.geometry.type === 'SphereGeometry') {
                        // Pulse color
                        const pulse = 0.6 + 0.4 * Math.sin(enemyAnimTime * 4);
                        part.material.color.setRGB(0, pulse * 0.2, 1); // Cyan pulse
                        
                        // Pulse size
                        const scale = 1 + 0.2 * Math.sin(enemyAnimTime * 4);
                        part.scale.set(scale, scale, scale);
                    }
                    
                    // Make visor flash
                    if (part === enemyVisor) {
                        const flash = Math.sin(enemyAnimTime * 2) > 0;
                        part.material.color.set(flash ? 0xff0000 : 0xdd0000);
                    }
                    
                    // Make weapon parts pulse with different intensities
                    if (part.geometry && part.geometry.type === 'SphereGeometry') {
                        const corePulse = 0.6 + 0.4 * Math.sin(enemyAnimTime * 4);
                        part.material.color.setRGB(0, corePulse, 1); // Cyan pulse
                        
                        // Scale the core for a more dynamic effect
                        const coreScale = 1 + 0.2 * Math.sin(enemyAnimTime * 4);
                        part.scale.set(coreScale, coreScale, coreScale);
                    }
                    
                    // Make barrel glow more subtly
                    if (part.geometry && part.geometry.type === 'CylinderGeometry') {
                        const barrelPulse = 0.4 + 0.2 * Math.sin(enemyAnimTime * 2);
                        part.material.color.setRGB(0, barrelPulse, 0.8);
                    }
                });
            }
            
            // Update enemy movement
            if (typeof EnemyMovement !== 'undefined') {
                EnemyMovement.update(enemy, 0.03);
            }
            
            // Test bullet spawn every 1.25 seconds but only during Get Ready phases after first lyrics
            // AND only if we haven't reached the early stop time (3 seconds before next lyric)
            if (Date.now() - lastBulletTime > 1250 && gameplayActive && inGetReadyPhase && 
                firstLyricsPlayed && Date.now() < earlyBulletStopTime) {
                console.log("AUTO BULLET CHECK: Can fire bullets! inGetReadyPhase:", inGetReadyPhase, 
                           "firstLyricsPlayed:", firstLyricsPlayed);
                
                // For first level, just use horizontal bullets
                if (currentLevel === 0) {
                    fireHorizontalLaneBullet();
                } else {
                    // For higher levels, use test bullets and other varieties
                    spawnTestBullet();
                }
                
                lastBulletTime = Date.now();
                console.log("Bullet fired, total bullets:", bullets.length);
            } else if (Date.now() - lastBulletTime > 1250 && gameplayActive) {
                // If we're past earlyBulletStopTime but still in Get Ready phase, log it
                if (inGetReadyPhase && firstLyricsPlayed && Date.now() >= earlyBulletStopTime) {
                    console.log("Early bullet stop active - no more bullets until next phase");
                } else {
                    console.log("AUTO BULLET CHECK: Cannot fire bullets. inGetReadyPhase:", inGetReadyPhase, 
                               "firstLyricsPlayed:", firstLyricsPlayed);
                }
                lastBulletTime = Date.now(); // Still reset the timer to avoid log spam
            }
            
            // Update all bullets only when gameplay is active
            if (gameplayActive) {
                // Update all bullets
                bullets.forEach(bullet => bullet.update());
                
                // Remove bullets that have gone past screen boundaries
                bullets = bullets.filter(bullet => {
                    if (bullet.mesh.position.z > 5 || bullet.mesh.position.z < -5) { // Top of screen or behind context window
                        bullet.remove(); // Use the remove method to clean up both bullet and trail
                        return false;
                    }
                    return true;
                });
                
                // Check for player collision with bullets
                bullets.forEach(bullet => {
                    if (!character) return; // Skip if character isn't loaded yet
                    
                    let distance = bullet.mesh.position.distanceTo(character.position);
                    let hitRadius = character.collisionRadius || 3.0; // Use defined radius or default
                    
                    if (distance < hitRadius) { // Use character's collision radius
                        console.log("Player hit by bullet at position:", bullet.mesh.position);
                        bullet.remove(); // Use the remove method
                        bullets = bullets.filter(b => b !== bullet);
                        
                        // Visual feedback when player is hit
                        mildShakeScreen(); // Use milder shake effect
                        const vignette = document.getElementById('vignette-overlay');
                        vignette.style.opacity = '0.8'; // Increased opacity for better visibility
                        
                        // Make character flash red briefly
                        const flashCharacter = () => {
                            // Track all materials we modify to restore them later
                            const originalMaterials = [];
                            
                            // Function to apply flash to a material
                            const applyFlashToMaterial = (material) => {
                                if (material && material.color) {
                                    // Store original color to restore later
                                    const originalColor = material.color.clone();
                                    originalMaterials.push({ material, originalColor });
                                    
                                    // Apply red flash
                                    material.color.set(0xff0000);
                                    
                                    // Also temporarily increase emissive for a glow effect
                                    if (material.emissive) {
                                        material.emissive.set(0xff0000);
                                    }
                                }
                            };
                            
                            // Function to recursively process a 3D object and its children
                            const processObject = (obj) => {
                                // If object has a material property, flash it
                                if (obj.material) {
                                    // Handle both single materials and material arrays
                                    if (Array.isArray(obj.material)) {
                                        obj.material.forEach(mat => applyFlashToMaterial(mat));
                                    } else {
                                        applyFlashToMaterial(obj.material);
                                    }
                                }
                                
                                // Process children recursively
                                if (obj.children && obj.children.length > 0) {
                                    obj.children.forEach(child => processObject(child));
                                }
                            };
                            
                            // Start processing from the character object
                            processObject(character);
                            
                            // Return a function to restore original colors
                            return () => {
                                originalMaterials.forEach(item => {
                                    try {
                                        // Restore color with a direct set instead of copy
                                        const hexColor = item.originalColor.getHex();
                                        item.material.color.set(hexColor);
                                        
                                        // Reset emissive if it was modified
                                        if (item.material.emissive) {
                                            item.material.emissive.set(0x000000);
                                        }
                                        
                                        // Force update
                                        item.material.needsUpdate = true;
                                    } catch (e) {
                                        console.error("Error restoring material:", e);
                                    }
                                });
                            };
                        };
                        
                        // Apply flash and schedule restoration
                        const restoreOriginalMaterials = flashCharacter();
                        
                        // Also update the debug display
                        const debugInfoElement = document.getElementById('debug-info');
                        if (debugInfoElement) {
                            debugInfoElement.textContent = "Debug: Player Hit!";
                            debugInfoElement.style.color = '#ff0000';
                        }
                        
                        // Reset everything after the flash duration
                        setTimeout(() => {
                            // Only use our improved reset function directly for all character parts
                            resetCompleteCharacter(character);
                            
                            // Reset vignette
                            if (vignette) {
                                vignette.style.opacity = '0';
                            }
                            
                            // Reset debug info
                            if (debugInfoElement) {
                                debugInfoElement.textContent = "Debug: Active";
                                debugInfoElement.style.color = '#00ff00';
                            }
                        }, 25);
                        
                        // Add character model debugging
                        console.log("Character structure when hit:", character);
                        if (character.children) {
                            console.log("Character has children:", character.children.length);
                            character.children.forEach((child, index) => {
                                console.log(`Child ${index}:`, child);
                                if (child.material) {
                                    console.log(`Child ${index} material:`, child.material);
                                }
                            });
                        }
                        
                        // Add a more subtle recoil animation instead of position change
                        if (character && bullet.mesh) {
                            // Get impact direction (from bullet to character)
                            const impactDirection = new THREE.Vector3();
                            impactDirection.subVectors(character.position, bullet.mesh.position).normalize();
                            
                            // Store the original rotation
                            const originalRotationX = character.rotation.x;
                            const originalRotationZ = character.rotation.z;
                            
                            // Apply a slight rotation in the direction of impact (lean back)
                            const rotationStrength = 0.15; // Very subtle
                            character.rotation.x += impactDirection.y * rotationStrength;
                            character.rotation.z += impactDirection.x * rotationStrength;
                            
                            // Gradually restore original rotation
                            setTimeout(() => {
                                character.rotation.x = originalRotationX + (impactDirection.y * rotationStrength * 0.5);
                                character.rotation.z = originalRotationZ + (impactDirection.x * rotationStrength * 0.5);
                            }, 50);
                            
                            setTimeout(() => {
                                character.rotation.x = originalRotationX;
                                character.rotation.z = originalRotationZ;
                            }, 100);
                        }
                    }
                });
            }
            
            // 10% chance per frame for steady projectile stream (only for levels beyond the first)
            if (Math.random() < 0.1 && gameplayActive && currentLevel > 0 && inGetReadyPhase && firstLyricsPlayed) {
                fireEnemyStream();
            }
            
            // 3% chance per frame for vertical lane bullets (only for levels beyond the first)
            if (Math.random() < 0.03 && gameplayActive && currentLevel > 0 && inGetReadyPhase && firstLyricsPlayed) {
                fireVerticalLaneBullet();
            }
            
            // 2% chance per frame for horizontal lane bullets (only for levels beyond the first)
            if (Math.random() < 0.02 && gameplayActive && currentLevel > 0 && inGetReadyPhase && firstLyricsPlayed) {
                fireHorizontalLaneBullet();
            }
            
            renderer.render(scene, camera);
            
            // Target timing and detection logic
            if (gameStarted && currentLyrics.length > 0) {
                const currentTime = audioElement.currentTime;
                
                // Debug information to help identify issues
                const debugInfoElement = document.getElementById('debug-info');
                if (debugInfoElement) {
                    let nextTime = nextLyricIndex < currentLyrics.length ? currentLyrics[nextLyricIndex].time : 0;
                    let timeRemaining = nextTime - currentTime;
                    
                    // Add current target info
                    if (currentTargetWord) {
                        const timeElapsedSinceTarget = targetStartTime ? (currentTime - targetStartTime).toFixed(2) : "N/A";
                        const timeWindowRemaining = targetStartTime ? (currentTimeWindow - (currentTime - targetStartTime)).toFixed(2) : "N/A";
                        
                        // CRITICAL DEBUG: Add target info and timing
                        debugInfoElement.textContent = `Time: ${currentTime.toFixed(2)}s | Target: "${currentTargetWord}" | Started: ${targetStartTime.toFixed(2)}s`;
                        debugInfoElement.textContent += ` | Elapsed: ${timeElapsedSinceTarget}s / ${currentTimeWindow}s (${timeWindowRemaining}s left)`;
                        
                        // Special flag for final line
                        if (nextLyricIndex >= currentLyrics.length) {
                            debugInfoElement.textContent += ` | *** FINAL LYRIC ***`;
                        }
                    } else {
                        debugInfoElement.textContent = `Time: ${currentTime.toFixed(2)}s | Next: ${nextTime.toFixed(2)}s | Remaining: ${timeRemaining.toFixed(2)}s`;
                    }
                    
                    // Add lyric info if available
                    if (nextLyricIndex < currentLyrics.length) {
                        const nextLyric = currentLyrics[nextLyricIndex].lyric.substring(0, 20) + "...";
                        debugInfoElement.textContent += ` | Next Lyric: ${nextLyric}`;
                    }
                }
                
                // CRITICAL: Dedicated check for the final target word timeout
                // This is a focused check specifically for the final line timeout issue
                if (currentTargetWord && targetStartTime && nextLyricIndex >= currentLyrics.length) {
                    const timeElapsed = currentTime - targetStartTime;
                    
                    // Log detailed information about the final line timing
                    console.log(`FINAL TARGET CHECK: "${currentTargetWord}" | Time: ${timeElapsed.toFixed(2)}s / ${currentTimeWindow}s | AudioTime: ${currentTime.toFixed(2)}s`);
                    
                    // Force timeout after 4 seconds for the final line
                    if (timeElapsed >= timeWindow) {
                        console.log(`*** FORCING FINAL LINE TIMEOUT ***`);
                        console.log(`"${currentTargetWord}" has timed out after ${timeElapsed.toFixed(2)} seconds`);
                        
                        // Trigger failure effects
                        showLyricIndicator(`Failed: ${currentTargetWord}`, false);
                        shakeScreen();
                        
                        // Update stats
                        totalTargets++;
                        incorrectInputs += currentTargetWord.length;
                        
                        // Update accuracy display
                        const accuracy = Math.round((correctInputs / (correctInputs + incorrectInputs)) * 100);
                        document.getElementById('accuracy').textContent = accuracy + "%";
                        
                        // Reset everything
                        document.getElementById('target').textContent = "";
                        document.getElementById('input').textContent = "";
                        currentTargetWord = "";
                        currentPlayerInput = "";
                        targetStartTime = null;
                        
                        // Mark song as completed
                        console.log("Song completed - final target timed out");
                        songCompleted = true;
                        
                        // Show "Battle Won" message after the final timeout
                        const getReadyMessage = document.getElementById('get-ready-message');
                        getReadyMessage.textContent = "BATTLE WON";
                        getReadyMessage.style.display = 'block';
                        getReadyMessage.style.color = '#ffdd00';
                        getReadyMessage.style.textShadow = '0 0 10px #ffaa00, 0 0 20px #ff8800, 0 0 30px #ff6600';
                        getReadyMessage.style.fontSize = '3.5rem';
                        getReadyMessage.style.letterSpacing = '2px';
                        getReadyMessage.style.animation = 'battle-won-pulse 1.5s infinite';
                    }
                }
                // Regular timeout check for all other target words
                else if (currentTargetWord && targetStartTime && timeWindow) {
                    const elapsedTime = currentTime - targetStartTime;
                    
                    // Debug logging for the final target timeout check
                    if (nextLyricIndex >= currentLyrics.length) {
                        console.log(`Final target check: ${elapsedTime.toFixed(2)}s / ${currentTimeWindow}s, Word: ${currentTargetWord}`);
                    }
                    
                    // Check if time window for current target has expired
                    if (elapsedTime >= currentTimeWindow) {
                        console.log("Time expired for target:", currentTargetWord, "| Window:", currentTimeWindow);
                        showLyricIndicator("Failed: " + currentTargetWord, false);
                        shakeScreen();
                        
                        // Update total targets count for stats
                        totalTargets++;
                        
                        // Count the remaining untyped characters as incorrect inputs
                        const remainingChars = currentTargetWord.length - currentPlayerInput.length;
                        if (remainingChars > 0) {
                            incorrectInputs += remainingChars;
                            
                            // Update accuracy to reflect the incomplete word
                            const accuracy = Math.round((correctInputs / (correctInputs + incorrectInputs)) * 100);
                            document.getElementById('accuracy').textContent = accuracy + "%";
                        }
                        
                        // Clear the target display but don't hide the container
                        document.getElementById('target').textContent = "";
                        document.getElementById('input').textContent = "";
                        
                        // Reset target variables
                        currentTargetWord = "";
                        currentPlayerInput = "";
                        targetStartTime = null;
                    }
                }
                
                // Check if it's time to show a new lyric
                if (currentLyrics.length > 0 && nextLyricIndex < currentLyrics.length && currentTime >= currentLyrics[nextLyricIndex].time) {
                    console.log('Lyric at time:', currentLyrics[nextLyricIndex].time);
                    console.log('Lyric:', currentLyrics[nextLyricIndex].lyric);
                    
                    // Only spawn a bullet during Get Ready phases after first lyrics have been played
                    if (inGetReadyPhase && firstLyricsPlayed) {
                        // Spawn a bullet on each lyric timestamp for rhythm-based gameplay
                        let bullet = new Bullet(
                            enemy.position.x - 5, 
                            enemy.position.y, 
                            enemy.position.z + 10 
                        );
                        scene.add(bullet.mesh);
                        bullets.push(bullet);
                        console.log("Bullet spawned on lyric timestamp at position:", bullet.mesh.position);
                    } else {
                        console.log("Skipped bullet spawn - not in Get Ready phase or first lyrics not played yet");
                    }
                    
                    if (currentLyrics[nextLyricIndex].target) {
                        console.log('Target:', currentLyrics[nextLyricIndex].target);
                        
                        // Clear previous target if it's still showing
                        if (currentTargetWord && targetStartTime) {
                            // Only mark as failed if we didn't just complete it
                            if (!justCompletedTarget) {
                                showLyricIndicator("Failed: " + currentTargetWord, false);
                                shakeScreen();
                                // Update total targets count for stats
                                totalTargets++;
                            }
                        }
                        
                        // Reset completion flag for new target
                        justCompletedTarget = false;
                        
                        currentTargetWord = currentLyrics[nextLyricIndex].target;
                        currentPlayerInput = "";
                        currentLyricIndex = nextLyricIndex;
                        targetStartTime = currentTime;
                        
                        // Special handling for the final target word
                        if (nextLyricIndex === currentLyrics.length - 1) {
                            console.log(`FINAL TARGET WORD SET: "${currentTargetWord}" at ${currentTime.toFixed(2)}s`);
                            
                            // Clear any existing timeout
                            if (window.finalLineTimeout) {
                                clearTimeout(window.finalLineTimeout);
                            }
                            
                            // Set a guaranteed timeout for the final word to ensure it consistently times out
                            window.finalLineTimeout = setTimeout(() => {
                                // Only trigger if this target is still active
                                if (currentTargetWord) {
                                    console.log("Final word timeout triggered via explicit timer");
                                    
                                    // Trigger fail state
                                    showLyricIndicator("Failed: " + currentTargetWord, false);
                                    shakeScreen();
                                    
                                    // Show red vignette effect
                                    const vignette = document.getElementById('vignette-overlay');
                                    vignette.style.opacity = '0.8'; // Increased opacity for better visibility
                                    setTimeout(() => {
                                        if (vignette) {
                                            vignette.style.opacity = '0';
                                        }
                                    }, 500);
                                    
                                    // Update stats
                                    totalTargets++;
                                    incorrectInputs += currentTargetWord.length - currentPlayerInput.length;
                                    
                                    // Update accuracy
                                    const accuracy = Math.round((correctInputs / (correctInputs + incorrectInputs)) * 100);
                                    document.getElementById('accuracy').textContent = accuracy + "%";
                                    
                                    // Reset everything
                                    document.getElementById('target').textContent = "";
                                    document.getElementById('input').textContent = "";
                                    currentTargetWord = "";
                                    currentPlayerInput = "";
                                    targetStartTime = null;
                                    
                                    // Mark song as completed
                                    console.log("Song completed - final target timed out via setTimeout");
                                    songCompleted = true;
                                    
                                    // Show "Battle Won" message after the final timeout
                                    const getReadyMessage = document.getElementById('get-ready-message');
                                    getReadyMessage.textContent = "BATTLE WON";
                                    getReadyMessage.style.display = 'block';
                                    getReadyMessage.style.color = '#ffdd00';
                                    getReadyMessage.style.textShadow = '0 0 10px #ffaa00, 0 0 20px #ff8800, 0 0 30px #ff6600';
                                    getReadyMessage.style.fontSize = '3.5rem';
                                    getReadyMessage.style.letterSpacing = '2px';
                                    getReadyMessage.style.animation = 'battle-won-pulse 1.5s infinite';
                                }
                            }, timeWindow * 1000); // 4 seconds in milliseconds
                        }
                        
                        // Calculate adaptive time window based on next lyric
                        currentTimeWindow = timeWindow; // Default to 4 seconds
                        
                        // If there's another lyric coming, check its timing
                        if (nextLyricIndex + 1 < currentLyrics.length) {
                            const currentLyricTime = currentLyrics[nextLyricIndex].time;
                            const nextLyricTime = currentLyrics[nextLyricIndex + 1].time;
                            const timeBetweenLyrics = (nextLyricTime - currentLyricTime); // In seconds
                            
                            // If next lyric comes in less than 4 seconds, use that time instead
                            // Subtract a small buffer (0.3s) for smoother transition
                            if (timeBetweenLyrics < timeWindow) {
                                currentTimeWindow = Math.max(timeBetweenLyrics - 0.3, 1.0); // Minimum 1s window
                                console.log('Reduced time window:', currentTimeWindow);
                            }
                        } else {
                            // For the final lyric, ensure we use the standard time window without modification
                            console.log('Final target word detected. Using fixed time window:', timeWindow);
                            currentTimeWindow = timeWindow;
                            
                            // Create a direct timeout for the final word to ensure it consistently times out
                            const finalWordTimeout = setTimeout(() => {
                                // Only trigger if this target is still active
                                if (currentTargetWord) {
                                    console.log("Final word timeout triggered via explicit timer");
                                    
                                    // Trigger fail state
                                    showLyricIndicator("Failed: " + currentTargetWord, false);
                                    shakeScreen();
                                    
                                    // Show red vignette effect
                                    const vignette = document.getElementById('vignette-overlay');
                                    vignette.style.opacity = '0.8'; // Increased opacity for better visibility
                                    setTimeout(() => {
                                        if (vignette) {
                                            vignette.style.opacity = '0';
                                        }
                                    }, 500);
                                    
                                    // Update stats
                                    totalTargets++;
                                    incorrectInputs += currentTargetWord.length - currentPlayerInput.length;
                                    
                                    // Update accuracy
                                    const accuracy = Math.round((correctInputs / (correctInputs + incorrectInputs)) * 100);
                                    document.getElementById('accuracy').textContent = accuracy + "%";
                                    
                                    // Reset everything
                                    document.getElementById('target').textContent = "";
                                    document.getElementById('input').textContent = "";
                                    currentTargetWord = "";
                                    currentPlayerInput = "";
                                    targetStartTime = null;
                                    
                                    // Mark song as completed
                                    console.log("Song completed - final target timed out via setTimeout");
                                    songCompleted = true;
                                    
                                    // Show "Battle Won" message after the final timeout
                                    const getReadyMessage = document.getElementById('get-ready-message');
                                    getReadyMessage.textContent = "BATTLE WON";
                                    getReadyMessage.style.display = 'block';
                                    getReadyMessage.style.color = '#ffdd00';
                                    getReadyMessage.style.textShadow = '0 0 10px #ffaa00, 0 0 20px #ff8800, 0 0 30px #ff6600';
                                    getReadyMessage.style.fontSize = '3.5rem';
                                    getReadyMessage.style.letterSpacing = '2px';
                                    getReadyMessage.style.animation = 'battle-won-pulse 1.5s infinite';
                                }
                            }, timeWindow * 1000); // 4 seconds in milliseconds
                        }
                        
                        // Update the target display - ensure it's visible
                        document.getElementById('target').textContent = currentTargetWord;
                        document.getElementById('input').textContent = "";
                        document.getElementById('input').style.color = "white";
                        document.getElementById('typing-container').style.display = 'block';
                        
                        // Hide any "Get Ready" message
                        document.getElementById('get-ready-message').style.display = 'none';
                    }
                    
                    // Display the lyric on screen with punctuation removed
                    const lyricsElement = document.getElementById('lyricsDisplay');
                    const cleanLyric = currentLyrics[nextLyricIndex].lyric.replace(/[^\w\s]/g, '');
                    lyricsElement.textContent = cleanLyric;
                    lyricsElement.style.opacity = 1;
                    
                    console.log("Displaying lyric #" + nextLyricIndex + ": " + cleanLyric);
                    
                    // Set firstLyricsPlayed to true after the very first lyric is displayed
                    if (!firstLyricsPlayed) {
                        console.log("FIRST LYRIC DISPLAYED - Setting firstLyricsPlayed to true");
                        firstLyricsPlayed = true;
                    }
                    
                    // Reset Get Ready phase flag
                    inGetReadyPhase = false;
                    console.log("Exiting Get Ready phase, inGetReadyPhase = " + inGetReadyPhase);
                    
                    // Calculate fade out timing based on next lyric
                    let fadeOutTime = 4000; // Default 4 seconds
                    
                    // If there's another lyric coming, check its timing
                    if (nextLyricIndex + 1 < currentLyrics.length) {
                        const currentLyricTime = currentLyrics[nextLyricIndex].time;
                        const nextLyricTime = currentLyrics[nextLyricIndex + 1].time;
                        const timeBetweenLyrics = (nextLyricTime - currentLyricTime) * 1000; // Convert to milliseconds
                        
                        // If next lyric comes in less than 4 seconds, adjust fadeout time
                        // Leave a small buffer (300ms) for a smoother transition
                        if (timeBetweenLyrics < 4000) {
                            fadeOutTime = Math.max(timeBetweenLyrics - 300, 500); // Minimum 0.5s fadeout
                        }
                    }
                    
                    // Fade out with appropriate timing
                    setTimeout(() => {
                        lyricsElement.style.opacity = 0;
                    }, fadeOutTime);
                    
                    // Important: Increment nextLyricIndex to move to the next lyric
                    nextLyricIndex++;
                    console.log("LYRIC COMPLETED: Incremented nextLyricIndex to: " + nextLyricIndex);
                    
                    // Mark that first lyrics have been played
                    if (!firstLyricsPlayed && nextLyricIndex > 0) {
                        firstLyricsPlayed = true;
                        console.log("IMPORTANT: First set of lyrics completed, bullets can now fire during Get Ready phases");
                        console.log("State update: inGetReadyPhase =", inGetReadyPhase, "firstLyricsPlayed =", firstLyricsPlayed);
                    } else {
                        console.log("firstLyricsPlayed check - Current state: firstLyricsPlayed =", firstLyricsPlayed, "nextLyricIndex =", nextLyricIndex);
                    }
                }
                
                // Ensure we have a valid timeout check for the final target
                // This check will run continuously even after the last timestamp
                if (currentTargetWord && targetStartTime) {
                    const elapsedTime = currentTime - targetStartTime;
                    
                    // Debug logging for the final target timeout check
                    if (nextLyricIndex >= currentLyrics.length) {
                        console.log(`Final target check: ${elapsedTime.toFixed(2)}s / ${currentTimeWindow}s, Word: ${currentTargetWord}`);
                    }
                    
                    // Check if time window for current target has expired
                    if (elapsedTime >= currentTimeWindow) {
                        console.log("Time expired for target:", currentTargetWord, "| Window:", currentTimeWindow);
                        showLyricIndicator("Failed: " + currentTargetWord, false);
                        shakeScreen();
                        
                        // Update total targets count for stats
                        totalTargets++;
                        
                        // Count the remaining untyped characters as incorrect inputs
                        const remainingChars = currentTargetWord.length - currentPlayerInput.length;
                        if (remainingChars > 0) {
                            incorrectInputs += remainingChars;
                            
                            // Update accuracy to reflect the incomplete word
                            const accuracy = Math.round((correctInputs / (correctInputs + incorrectInputs)) * 100);
                            document.getElementById('accuracy').textContent = accuracy + "%";
                        }
                        
                        // Clear the target display but don't hide the container
                        document.getElementById('target').textContent = "";
                        document.getElementById('input').textContent = "";
                        
                        // Reset target variables
                        currentTargetWord = "";
                        currentPlayerInput = "";
                        targetStartTime = null;
                    }
                }
                
                // Handle section gap - if we have more than 4 seconds until the next lyric, show "Get Ready"
                if (currentLyrics.length > 0 && nextLyricIndex < currentLyrics.length && !currentTargetWord) {
                    const nextLyricTime = currentLyrics[nextLyricIndex].time;
                    const timeUntilNextLyric = nextLyricTime - currentTime;
                    
                    // Show "Get Ready" if next lyric is more than 4 seconds away
                    if (timeUntilNextLyric > 4) {
                        // We're in a gap between sections - ensure typing UI is ready
                        document.getElementById('typing-container').style.display = 'block';
                        document.getElementById('target').textContent = "";
                        document.getElementById('input').textContent = "";
                        
                        // Make sure we show "Get Ready" (not "Battle Won") for mid-song gaps
                        const getReadyMessage = document.getElementById('get-ready-message');
                        getReadyMessage.textContent = "GET READY";
                        getReadyMessage.style.display = 'block';
                        getReadyMessage.style.color = '#00ffff';
                        getReadyMessage.style.textShadow = '0 0 10px #00ffff, 0 0 20px #00ffff';
                        getReadyMessage.style.fontSize = '3rem';
                        getReadyMessage.style.letterSpacing = 'normal';
                        getReadyMessage.style.animation = 'pulse 2s infinite';
                        
                        // Add this to track we're in a Get Ready phase
                        inGetReadyPhase = true;
                        console.log("Entering Get Ready phase, bullets can fire: " + firstLyricsPlayed);
                        
                        // Calculate early bullet stop time (3 seconds before next lyric)
                        earlyBulletStopTime = Date.now() + (timeUntilNextLyric - 3) * 1000;
                        console.log("Early bullet stop time set to:", earlyBulletStopTime);
                    } else if (timeUntilNextLyric <= 0.05 && timeUntilNextLyric > -0.2) {
                        // More precise timing: only force advance if we're extremely close to the time
                        // This reduces unnecessary forced advances while still preventing getting stuck
                        console.log("Forcing advance to next lyric due to proximity");
                        const lyricsElement = document.getElementById('lyricsDisplay');
                        const cleanLyric = currentLyrics[nextLyricIndex].lyric.replace(/[^\w\s]/g, '');
                        lyricsElement.textContent = cleanLyric;
                        lyricsElement.style.opacity = 1;
                        
                        // Set firstLyricsPlayed to true after the very first lyric is displayed
                        if (!firstLyricsPlayed) {
                            console.log("FIRST LYRIC DISPLAYED (via forced advance) - Setting firstLyricsPlayed to true");
                            firstLyricsPlayed = true;
                        }
                        
                        // Reset Get Ready phase flag
                        inGetReadyPhase = false;
                        
                        // If this lyric has a target, update the target word
                        if (currentLyrics[nextLyricIndex].target) {
                            currentTargetWord = currentLyrics[nextLyricIndex].target;
                            const cleanTarget = currentTargetWord.replace(/[^\w\s]/g, '');
                            document.getElementById('target').textContent = cleanTarget;
                            document.getElementById('input').textContent = "";
                            document.getElementById('get-ready-message').style.display = 'none';
                            targetStartTime = currentTime;
                        }
                        
                        // Increment to the next lyric
                        nextLyricIndex++;
                    }
                }
            }
        }

        // Function to show lyric indicator (success or failure)
        function showLyricIndicator(text, success) {
            const indicatorElement = document.getElementById('lyricIndicator');
            
            // Reset by removing any existing animation classes
            indicatorElement.classList.remove('float-fade');
            
            // Set the text and styling
            indicatorElement.textContent = text;
            indicatorElement.style.color = success ? "#00ff00" : "#ff0000";
            indicatorElement.style.textShadow = success ? "0 0 20px #00ff00" : "0 0 20px #ff0000";
            
            // Ensure it's visible initially without animation
            indicatorElement.style.opacity = 1;
            
            // Make sure the typing container is always visible after showing an indicator
            document.getElementById('typing-container').style.display = 'block';
            
            // Force a reflow to ensure the new animation starts properly
            void indicatorElement.offsetWidth;
            
            // Start the floating fade animation
            indicatorElement.classList.add('float-fade');
        }
        
        // Function to display success particles
        function showSuccessParticles() {
            const typingContainer = document.getElementById('typing-container');
            const rect = typingContainer.getBoundingClientRect();
            
            // Increased number of particles for higher density
            const numParticles = 45;
            
            // Create particles that burst outward from the typing container border
            for (let i = 0; i < numParticles; i++) {
                let particle = document.createElement('div');
                particle.className = 'particle';
                
                // Calculate position around the perimeter of the typing container
                const angle = (i / numParticles) * Math.PI * 2;
                
                // Calculate position on the border
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const radiusX = rect.width / 2;
                const radiusY = rect.height / 2;
                
                // Position on the border
                const posX = centerX + Math.cos(angle) * radiusX;
                const posY = centerY + Math.sin(angle) * radiusY;
                
                // Direction is outward from the center
                const distance = 80 + Math.random() * 120;
                const xMove = Math.cos(angle) * distance;
                const yMove = Math.sin(angle) * distance;
                
                // Set custom properties for the animation
                particle.style.setProperty('--x-move', `${xMove}px`);
                particle.style.setProperty('--y-move', `${yMove}px`);
                
                // Position particles on the border of the typing container
                particle.style.left = posX + 'px';
                particle.style.top = posY + 'px';
                
                // Append to the body to ensure they're visible
                document.body.appendChild(particle);
                
                // Remove particle after animation completes
                setTimeout(() => particle.remove(), 800);
            }
            
            // Add some extra randomly positioned particles for more density
            for (let i = 0; i < 15; i++) {
                let particle = document.createElement('div');
                particle.className = 'particle';
                
                // Calculate random position on or near the border
                const angle = Math.random() * Math.PI * 2;
                const randomOffset = (Math.random() * 0.2) - 0.1; // small random offset
                
                // Calculate position on the border with slight randomness
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const radiusX = rect.width / 2 * (1 + randomOffset);
                const radiusY = rect.height / 2 * (1 + randomOffset);
                
                // Position near the border
                const posX = centerX + Math.cos(angle) * radiusX;
                const posY = centerY + Math.sin(angle) * radiusY;
                
                // Direction is outward but with varied angles
                const randomAngle = angle + (Math.random() * 0.5 - 0.25);
                const distance = 60 + Math.random() * 140;
                const xMove = Math.cos(randomAngle) * distance;
                const yMove = Math.sin(randomAngle) * distance;
                
                // Set custom properties for the animation
                particle.style.setProperty('--x-move', `${xMove}px`);
                particle.style.setProperty('--y-move', `${yMove}px`);
                
                // Position particles on or near the border
                particle.style.left = posX + 'px';
                particle.style.top = posY + 'px';
                
                // Append to the body to ensure they're visible
                document.body.appendChild(particle);
                
                // Remove particle after animation completes
                setTimeout(() => particle.remove(), 800);
            }
        }
        
        // Function to shake the screen when a word fails
        function shakeScreen() {
            // Get overlay element
            let overlay = document.getElementById('overlay');
            
            // Add strong shake class
            overlay.classList.add('strong-shake');
            
            // Add red vignette effect using dedicated overlay
            let vignetteOverlay = document.getElementById('vignette-overlay');
            vignetteOverlay.classList.add('red-vignette');
            
            // Remove classes after animations complete
            setTimeout(() => {
                overlay.classList.remove('strong-shake');
                vignetteOverlay.classList.remove('red-vignette');
            }, 1200);
        }
        
        // A milder screen shake effect using direct style manipulation
        function mildShakeScreen() {
            // Get overlay element with null check
            const overlay = document.getElementById('overlay');
            if (!overlay) return;
            
            // Apply mild shake using direct style manipulation
            overlay.style.transform = 'translate(2px, 2px)';
            
            // Quick reset sequence for mild shake effect
            setTimeout(() => { overlay.style.transform = 'translate(-2px, -1px)'; }, 25);
            setTimeout(() => { overlay.style.transform = 'translate(1px, -1px)'; }, 50);
            setTimeout(() => { overlay.style.transform = 'translate(-1px, 0px)'; }, 75);
            setTimeout(() => { overlay.style.transform = ''; }, 100); // Back to normal
        }
        
        // Variables for tracking game stats
        let targetsHit = 0;
        let totalTargets = 0;
        let correctInputs = 0;
        let totalInputs = 0;
        let incorrectInputs = 0;
        let songCompleted = false;
        
        // Function to update the track
        function updateTrack() {
            // Update player stats for the new level
            if (currentLevel > 0) {
                // Increase difficulty slightly for each level
                document.getElementById('character-level').textContent = currentLevel + 1;
                
                // Speed text updates based on level
                if (currentLevel <= 3) {
                    document.getElementById('character-speed').textContent = "Normal";
                } else if (currentLevel <= 6) {
                    document.getElementById('character-speed').textContent = "Fast";
                } else {
                    document.getElementById('character-speed').textContent = "Insane";
                }
            }
            
            // Check if we're at the end of the tracks
            if (currentLevel >= tracks.length) {
                console.log("End of tracks reached - game completed!");
                currentLevel = 0; // Reset to first track (loop)
            }
            
            // Reset target tracking variables
            currentTargetWord = "";
            currentPlayerInput = "";
            targetStartTime = null;
            
            // Reset Get Ready phase tracking variables
            inGetReadyPhase = false;
            firstLyricsPlayed = false;
            console.log("Track changed, reset bullet firing flags");
            
            audioElement.src = tracks[currentLevel].src;
            document.getElementById('trackName').textContent = `Level ${currentLevel + 1}: ${tracks[currentLevel].name}`;
            document.getElementById('current-track').textContent = tracks[currentLevel].name;
            
            // Reset beats and lyrics
            currentBeats = tracks[currentLevel].beats || [];
            nextBeatIndex = 0;
            
            // Reset tracking stats
            document.getElementById('targets-hit').textContent = "0";
            document.getElementById('accuracy').textContent = "0%";
            
            // Reset enemy damage system for the new level
            EnemyDamage.resetSystem();
            
            // Load lyrics if available
            loadLRC();
            
            // Start playing the track
            audioElement.play();
        }
        
        // Function to load and parse LRC file
        function loadLRC() {
            // Clear current lyrics
            currentLyrics = [];
            nextLyricIndex = 0;
            
            // For now, hardcode the lyrics for March at Dawn
            if (tracks[currentLevel].lrc) {
                console.log(`Loading lyrics for ${tracks[currentLevel].name}`);
                
                // Create lyric objects with timestamps (in seconds) and text
                // Using exact timestamps from the LRC file - properly calibrated
                const rawLyrics = [
                    // First section - timestamps are correct
                    { time: 11.36, text: "IN THE BLAZE OF YOUTH'S PROUD DAY," },
                    { time: 16.04, text: "MARCHING FORTH WHERE HONOR LAY," },
                    { time: 20.45, text: "BELIEF AS CLEAR AS A CALL TO ARMS," },
                    { time: 25.12, text: "THE SOUND OF GLORY, IN THE FACE OF UNKNOWN HARMS." },
                    { time: 33.95, text: "YET BENEATH THE HYMNS OF SOARING HIGHS," },
                    { time: 39.13, text: "HIDE WHISPERS OF A STORMY SIGH." },
                    { time: 44.17, text: "LOSING SIGHT IN THE DAWNING LIGHT," },
                    { time: 48.28, text: "I CHARGE AHEAD, INTO THE FIGHT," },
                    { time: 53.35, text: "HEART ABLAZE WITH RIGHTEOUS ZEAL," },
                    { time: 57.64, text: "BLINDED TO THE WHOLE ORDEAL." },
                    { time: 81.70, text: "HEART ABLAZE WITH RIGHTEOUS ZEAL," },
                    { time: 86.35, text: "BLINDED TO THE WHOLE ORDEAL." },
                    
                    // Second section - recalibrated with -10s offset to fix timing
                    { time: 100.39, text: "FIRST CRACKS IN THE ARMOR'S SHEEN," },       // Was 105.39
                    { time: 104.58, text: "NOT ALL IS AS IT ONCE HAD SEEMED," },        // Was 109.58
                    { time: 109.38, text: "SEEDS OF DOUBT, WHERE CONVICTION REIGNED," },// Was 114.38
                    { time: 113.90, text: "BY THE BLOOD OF COUNTLESS, FAITH HAS BEEN STAINED." }, // Was 118.90
                    
                    // Third section - recalibrated timestamps
                    { time: 148.64, text: "FIRST CRACKS, A FOREBODING SOUND," },        // Was 153.64
                    { time: 155.65, text: "AS THE GROUND BENEATH SHAKES, MY FEARS ABOUND." }, // Was 160.65
                    { time: 164.15, text: "LOSING SIGHT IN THE DAWNING LIGHT," },       // Was 169.15
                    { time: 167.71, text: "AND I, I CHARGE AHEAD, INTO THE FIGHT," },   // Was 172.71
                    { time: 173.46, text: "HEART ABLAZE WITH RIGHTEOUS ZEAL," },        // Was 178.46
                    { time: 177.38, text: "BLINDED TO THE WHOLE ORDEAL." },             // Was 182.38
                    
                    // Fourth section - recalibrated timestamps
                    { time: 202.69, text: "THROUGH THE FOG OF WAR'S EMBRACE," },        // Was 207.69
                    { time: 207.15, text: "SEARCHING FOR THE TRUTH'S DIM TRACE," },     // Was 212.15
                    { time: 211.85, text: "SIRENS CALL NOT FOR GLORY'S SAKE," },        // Was 216.85
                    { time: 216.51, text: "I RETURN TO HELL, AS THE MOUNTAINS QUAKE." },// Was 221.51
                    { time: 229.78, text: "LOSING SIGHT IN THE DAWNING LIGHT," },       // Was 234.78
                    { time: 233.21, text: "AND I, I CHARGE AHEAD, INTO THE FIGHT," },   // Was 238.21
                    { time: 238.99, text: "HEART ABLAZE WITH RIGHTEOUS ZEAL," },        // Was 243.99
                    { time: 243.11, text: "BLINDED TO THE WHOLE ORDEAL." },             // Was 248.11
                    
                    // Final section - further recalibrated timestamps
                    { time: 249.01, text: "IN THE SILENCE, MY SOUL NOW WEEPS." },       // Was 254.01
                    { time: 277.76, text: "AS THE DAWN FADES INTO NIGHT," },            // Was 282.76
                    { time: 282.08, text: "LESSONS LEARNED IN THE HARSH DAYLIGHT," },   // Was 287.08
                    { time: 286.79, text: "WITH EACH STEP, THE PATH GROWS STEEP," },    // Was 291.79
                    { time: 291.72, text: "IN THE SILENCE, MY SOUL NOW WEEPS." },       // Was 296.72
                    { time: 306.90, text: "IN THE SILENCE, MY SOUL NOW WEEPS." }        // Was 311.90
                ];
                
                // Match lyrics with target words
                let targetIndex = 0;
                
                // Process each lyric and add targets
                rawLyrics.forEach(lyric => {
                    // Create a copy of the lyric object
                    const lyricObj = {
                        time: lyric.time,
                        lyric: lyric.text
                    };
                    
                    // Check if we should assign a target to this lyric
                    if (targetIndex < marchAtDawnLyrics.length) {
                        const target = marchAtDawnLyrics[targetIndex];
                        
                        // Improved target matching - make both strings comparable by removing punctuation
                        // and checking if the target keywords are contained in the lyric
                        const cleanLyric = lyric.text.replace(/[^\w\s]/g, '');
                        const cleanTarget = target.replace(/[^\w\s]/g, '');
                        
                        // Special handling for the final "MY SOUL NOW WEEPS" line
                        if (lyric.time >= 306.0 && cleanLyric.includes("MY SOUL NOW WEEPS")) {
                            lyricObj.target = "MY SOUL NOW WEEPS";
                            console.log(`Assigning final target "MY SOUL NOW WEEPS" to lyric: "${lyric.text}" at time ${lyric.time}`);
                            targetIndex++;
                        }
                        // Check if the clean target is part of the clean lyric
                        else if (cleanLyric.includes(cleanTarget) || 
                            // Special cases for phrases that might need exact matching
                            (cleanLyric.includes("RIGHTEOUS ZEAL") && cleanTarget === "RIGHTEOUS ZEAL") ||
                            (cleanLyric.includes("WHOLE ORDEAL") && cleanTarget === "WHOLE ORDEAL")) {
                            
                            lyricObj.target = target;
                            console.log(`Assigning target "${target}" to lyric: "${lyric.text}" at time ${lyric.time}`);
                            targetIndex++;
                        }
                    }
                    
                    // Add to current lyrics array
                    currentLyrics.push(lyricObj);
                });
                
                console.log("Successfully matched lyrics with targets");
                console.log(`Loaded ${currentLyrics.length} lyric lines for ${tracks[currentLevel].name}`);
                
                // Debug output of all lyrics with targets
                for (let i = 0; i < currentLyrics.length; i++) {
                    const lyric = currentLyrics[i];
                    if (lyric.target) {
                        console.log(`Lyric at ${lyric.time}s: "${lyric.lyric}" - Target: "${lyric.target}"`);
                    } else {
                        console.log(`Lyric at ${lyric.time}s: "${lyric.lyric}" - No target`);
                    }
                }
                
                // Add additional debugging output to help identify timing issues at specific sections
                console.log("--- Final section timestamps ---");
                for (let i = 0; i < currentLyrics.length; i++) {
                    if (currentLyrics[i].lyric.includes("MY SOUL NOW WEEPS") || 
                        currentLyrics[i].lyric.includes("FADES INTO NIGHT") ||
                        currentLyrics[i].lyric.includes("HARSH DAYLIGHT") ||
                        currentLyrics[i].lyric.includes("PATH GROWS STEEP")) {
                        console.log(`Lyric at ${currentLyrics[i].time}s: "${currentLyrics[i].lyric}" - Has target: ${currentLyrics[i].target ? "Yes" : "No"}`);
                    }
                }
            }
            
            // Set track data for enemy damage system
            if (currentLyrics && currentLyrics.length > 0) {
                EnemyDamage.setCurrentTrack({lyrics: currentLyrics});
                console.log(`Set ${currentLyrics.length} lyrics for enemy damage calculation`);
            }
            
            return currentLyrics;
        }
        
        // Function to start background music
        function startMusic() {
            // Add error handler for audio loading failures
            audioElement.onerror = function() {
                console.error('Error loading audio file:', audioElement.src);
                
                // Display error message to player
                const trackDisplay = document.getElementById('trackName');
                trackDisplay.textContent = 'Error loading audio - Check console';
                trackDisplay.style.color = 'red';
                
                // Try to advance to next track after a delay
                setTimeout(() => {
                    currentLevel++;
                    updateTrack();
                }, 3000);
            };
            
            // Set source but don't autoplay - this will happen on user interaction
            audioElement.src = "assets/music/title_concrete_jungle.mp3";
            
            // Update track display
            const trackDisplay = document.getElementById('trackName');
            trackDisplay.textContent = "Title: Concrete Jungle";
            trackDisplay.style.color = '#00ffcc';
        }
        
        // Function to stop background music
        function stopMusic() {
            audioElement.pause();
            audioElement.currentTime = 0; // Reset to beginning
        }
        
        // Function to pause background music
        function pauseMusic() {
            audioElement.pause();
        }
        
        // Function to resume background music
        function resumeMusic() {
            audioElement.play();
        }
        
        // Add event listener for track completion
        audioElement.addEventListener('ended', () => {
            currentLevel++;
            updateTrack();
        });
        
        // Set the initial audio source
        audioElement.src = tracks[currentLevel].src;
        
        // Start game logic
        document.getElementById('startButton').addEventListener('click', () => {
            // Hide main menu
            document.getElementById('mainMenu').style.display = 'none';
            
            // Start the game
            gameStarted = true;
            updateTrack();
            audioElement.play().catch(error => console.error("Audio play error:", error));
        });

        document.getElementById('resumeButton').addEventListener('click', () => {
            // Hide pause menu
            document.getElementById('pauseMenu').style.display = 'none';
            
            // Resume audio
            audioElement.play();
            
            // Resume game
            gameStarted = true;
        });
        
        document.getElementById('restartLevelButton').addEventListener('click', () => {
            // Hide pause menu
            document.getElementById('pauseMenu').style.display = 'none';
            
            // Hide get ready message
            document.getElementById('get-ready-message').style.display = 'none';
            
            // Reset characters to off-screen
            if (character) character.position.set(-250, 2, 0);
            if (enemy) enemy.position.set(250, 2, 0);
            
            // Clear all bullets
            if (bullets && bullets.length > 0) {
                bullets.forEach(bullet => {
                    if (bullet && bullet.remove) bullet.remove();
                });
                bullets = [];
            }
            
            // Set gameplay state
            gameplayActive = false; // Will be set to true after animation
            
            // Restart current track from beginning
            audioElement.currentTime = 0;
            audioElement.play();
            
            // Reset game variables
            currentLyricIndex = 0;
            nextLyricIndex = 0;
            nextBeatIndex = 0;
            currentTargetWord = "";
            currentPlayerInput = "";
            targetStartTime = null;
            
            // Reset stats
            targetsHit = 0;
            totalTargets = 0;
            correctInputs = 0;
            totalInputs = 0;
            incorrectInputs = 0;
            document.getElementById('targets-hit').textContent = "0";
            document.getElementById('accuracy').textContent = "0%";
            
            // Clear displays
            document.getElementById('target').textContent = "";
            document.getElementById('input').textContent = "";
            
            // Update track (which starts playback)
            updateTrack();
            
            // Start character entrance animation
            animateCharacterEntrance();
        });
        
        document.getElementById('restartCampaignButton').addEventListener('click', () => {
            // Hide pause menu
            document.getElementById('pauseMenu').style.display = 'none';
            
            // Hide get ready message
            document.getElementById('get-ready-message').style.display = 'none';
            
            // Reset characters to off-screen
            if (character) character.position.set(-250, 2, 0);
            if (enemy) enemy.position.set(250, 2, 0);
            
            // Clear all bullets
            if (bullets && bullets.length > 0) {
                bullets.forEach(bullet => {
                    if (bullet && bullet.remove) bullet.remove();
                });
                bullets = [];
            }
            
            // Set gameplay state
            gameplayActive = false; // Will be set to true after animation
            
            // Reset to first level
            currentLevel = 0;
            
            // Reset game variables
            currentLyricIndex = 0;
            nextLyricIndex = 0;
            nextBeatIndex = 0;
            currentTargetWord = "";
            currentPlayerInput = "";
            targetStartTime = null;
            
            // Reset stats
            targetsHit = 0;
            totalTargets = 0;
            correctInputs = 0;
            totalInputs = 0;
            incorrectInputs = 0;
            document.getElementById('targets-hit').textContent = "0";
            document.getElementById('accuracy').textContent = "0%";
            document.getElementById('character-score').textContent = "0";
            document.getElementById('character-level').textContent = "1";
            
            // Clear displays
            document.getElementById('target').textContent = "";
            document.getElementById('input').textContent = "";
            
            // Update track (which starts playback)
            updateTrack();
            
            // Start character entrance animation
            animateCharacterEntrance();
        });
        
        document.getElementById('quitButton').addEventListener('click', returnToMenu);
        
        // Start animation loop
        animate();
        
        // Initialize game stats
        document.getElementById('character-level').textContent = "1";
        document.getElementById('character-speed').textContent = "Normal";
        document.getElementById('character-score').textContent = "0";
        document.getElementById('current-track').textContent = "None";
        document.getElementById('accuracy').textContent = "0%";
        document.getElementById('targets-hit').textContent = "0";
        
        // Debug function to spawn test bullets
        function spawnTestBullet() {
            console.log("Spawning test bullet");
            // Spawn with random position near enemy
            let x = enemy.position.x;
            let y = enemy.position.y;
            let z = enemy.position.z;
            
            let testBullet = new Bullet(x, y, z);
            
            // Override the default update method to move toward player
            testBullet.update = function() { 
                this.mesh.position.x -= 0.3; // Move toward player (left) - doubled from 0.15
                
                // Update trail position to follow behind bullet
                this.trailMesh.position.copy(this.mesh.position);
                this.trailMesh.position.x += 3.0; // Adjusted for the new custom trail shape
            };
            
            // Rotate the trail to point along the X axis (for left/right movement)
            // This replaces the default Y axis rotation
            testBullet.trailMesh.rotation.x = 0;
            testBullet.trailMesh.rotation.z = Math.PI / 2;
            
            // No need to add to scene here, the constructor does it
            bullets.push(testBullet);
            
            // Add visual indication to debug panel
            const debugInfoElement = document.getElementById('debug-info');
            if (debugInfoElement) {
                debugInfoElement.textContent += " | Bullet Spawned!";
            }
        }
        
        // Function to fire a steady stream of projectiles from the enemy
        function fireEnemyStream() {
            let bullet = new Bullet(enemy.position.x, enemy.position.y, enemy.position.z + 1); // Spawn just in front of enemy
            
            // Override the default update method to move toward player
            bullet.update = function() { 
                this.mesh.position.x -= 0.3; // Move toward player (left) - doubled from 0.15
                
                // Update trail position to follow behind bullet
                this.trailMesh.position.copy(this.mesh.position);
                this.trailMesh.position.x += 3.0; // Adjusted for the new custom trail shape
            };
            
            // Rotate the trail to point along the X axis (for left/right movement)
            // This replaces the default Y axis rotation
            bullet.trailMesh.rotation.x = 0;
            bullet.trailMesh.rotation.z = Math.PI / 2;
            
            // No need to add to scene here, the constructor does it
            bullets.push(bullet);
        }
        
        // Function to fire bullets from the top in vertical lanes
        function fireVerticalLaneBullet() {
            let lane = verticalLaneX[Math.floor(Math.random() * verticalLaneX.length)];
            let bullet = new Bullet(lane, 0, 5); // Start at top
            
            // Override the default update method for downward movement
            bullet.update = function() { 
                this.mesh.position.z -= 0.4; // Move downward - doubled from 0.2
                
                // Update trail position to follow behind bullet
                this.trailMesh.position.copy(this.mesh.position);
                this.trailMesh.position.z += 3.0; // Adjusted for the new custom trail shape
            };
            
            // No need to add to scene here, the constructor does it
            bullets.push(bullet);
        }
        
        // Function to fire horizontal bullets at head and feet heights
        function fireHorizontalLaneBullet() {
            let height = horizontalLaneY[Math.floor(Math.random() * horizontalLaneY.length)];
            let bullet = new Bullet(5, height, 0); // Start from right side
            
            // For first level, make bullets slightly larger and more visible
            if (currentLevel === 0) {
                bullet.mesh.scale.set(1.2, 1.2, 1.2);
                bullet.material.emissiveIntensity = 0.7; // More intense glow
            }
            
            // Add debug logging
            console.log("Firing horizontal bullet. inGetReadyPhase: " + inGetReadyPhase + 
                        ", firstLyricsPlayed: " + firstLyricsPlayed);
            
            // Override the default update method for leftward movement (toward player)
            bullet.update = function() { 
                this.mesh.position.x -= 0.4; // Move left toward player - doubled from 0.2
                
                // Update trail position to follow behind bullet
                this.trailMesh.position.copy(this.mesh.position);
                this.trailMesh.position.x += 3.0; // Adjusted for the new custom trail shape
            };
            
            // Rotate the trail to point along the X axis (for left/right movement)
            // This replaces the default Y axis rotation
            bullet.trailMesh.rotation.x = 0;
            bullet.trailMesh.rotation.z = Math.PI / 2;
            
            // No need to add to scene here, the constructor does it
            bullets.push(bullet);
        }
        
        // Event Listeners
        document.addEventListener('keydown', (event) => {
            if (gameStarted) {
                if (event.key === 'Escape') {
                    // Toggle pause menu
                    const pauseMenu = document.getElementById('pauseMenu');
                    if (pauseMenu.style.display === 'block') {
                        pauseMenu.style.display = 'none';
                        audioElement.play();
                    } else {
                        pauseMenu.style.display = 'block';
                        audioElement.pause();
                    }
                } else if (/^[a-zA-Z ]$/.test(event.key)) {
                    // Process alphabetic keys and space for typing
                    if (currentTargetWord) {
                        let key = event.key;
                        if (key === ' ') {
                            key = ' '; // Keep space as space
                        } else {
                            key = key.toUpperCase(); // Convert letters to uppercase
                        }
                        
                        // Track total inputs for accuracy calculation
                        totalInputs++;
                        
                        // Add the key to player input
                        currentPlayerInput += key;
                        document.getElementById('input').textContent = currentPlayerInput;
                        
                        // Check if input matches target
                        if (currentTargetWord.startsWith(currentPlayerInput)) {
                            // Correct input
                            correctInputs++;
                            
                            // If complete match, mark as correct
                            if (currentPlayerInput === currentTargetWord) {
                                console.log("Target completed correctly!");
                                
                                // Increment targets hit
                                targetsHit++;
                                totalTargets++;
                                document.getElementById('targets-hit').textContent = targetsHit;
                                
                                // Update accuracy
                                const accuracy = Math.round((correctInputs / (correctInputs + incorrectInputs)) * 100);
                                document.getElementById('accuracy').textContent = accuracy + "%";
                                
                                // Update character score
                                const currentScore = parseInt(document.getElementById('character-score').textContent);
                                document.getElementById('character-score').textContent = currentScore + 100;
                                
                                // Immediately reset target tracking to prevent the "Failed" message
                                // Save the current target for the success message
                                const completedTarget = currentTargetWord;
                                
                                // Reset target variables so timer check won't trigger failure
                                targetStartTime = null;
                                currentTargetWord = "";
                                
                                // Show success feedback
                                document.getElementById('input').style.color = "#00ff00";
                                showLyricIndicator(`Success: ${completedTarget}`, true);
                                showSuccessParticles();
                                
                                // Apply damage to enemy based on the completed target
                                // Get current lyrics for damage calculation
                                let currentLyricText = "";
                                if (currentLyricIndex < currentLyrics.length && currentLyrics[currentLyricIndex]) {
                                    currentLyricText = currentLyrics[currentLyricIndex].lyric || "";
                                }
                                
                                // Apply damage through the damage system
                                const damageResult = EnemyDamage.applyDamage(completedTarget, true, currentLyricText);
                                
                                // Enhanced visual feedback for significant damage
                                if (damageResult.isFinalLine || damageResult.isDefeated) {
                                    // Show more intense particle effects for final damage
                                    showSuccessParticles();
                                    setTimeout(() => showSuccessParticles(), 200);
                                    setTimeout(() => showSuccessParticles(), 400);
                                    
                                    // Flash the screen with a stronger effect
                                    const intensity = 0.3; // 30% intensity
                                    mildShakeScreen(intensity * 1.5);
                                }
                                
                                // Clear the target display to indicate completion after a short delay
                                setTimeout(() => {
                                    // Clear target and input displays
                                    document.getElementById('target').textContent = "";
                                    document.getElementById('input').textContent = "";
                                    
                                    // Current player input already cleared
                                    currentPlayerInput = "";
                                    
                                    // Check if this was the last lyric in the song
                                    if (nextLyricIndex >= currentLyrics.length) {
                                        console.log("Song completed - last target typed successfully");
                                        // Set song completion flag
                                        songCompleted = true;
                                        
                                        // Show "Battle Won" message after successful completion of the final lyric
                                        const getReadyMessage = document.getElementById('get-ready-message');
                                        getReadyMessage.textContent = "BATTLE WON";
                                        getReadyMessage.style.display = 'block';
                                        getReadyMessage.style.color = '#ffdd00';
                                        getReadyMessage.style.textShadow = '0 0 10px #ffaa00, 0 0 20px #ff8800, 0 0 30px #ff6600';
                                        getReadyMessage.style.fontSize = '3.5rem';
                                        getReadyMessage.style.letterSpacing = '2px';
                                        getReadyMessage.style.animation = 'battle-won-pulse 1.5s infinite';
                                    }
                                }, 500);
                            }
                        } else {
                            // Wrong input - show error but don't reset input
                            console.log("Incorrect input!");
                            document.getElementById('input').style.color = "#ff0000";
                            document.getElementById('overlay').classList.add('shake');
                            
                            // Increment incorrect inputs counter
                            incorrectInputs++;
                            
                            // Remove only the last character that was incorrect
                            currentPlayerInput = currentPlayerInput.slice(0, -1);
                            document.getElementById('input').textContent = currentPlayerInput;
                            
                            // Update accuracy
                            const accuracy = Math.round((correctInputs / (correctInputs + incorrectInputs)) * 100);
                            document.getElementById('accuracy').textContent = accuracy + "%";
                            
                            // Reset visual feedback after a short delay
                            setTimeout(() => {
                                document.getElementById('input').style.color = "white";
                                document.getElementById('overlay').classList.remove('shake');
                            }, 500);
                        }
                    }
                } else if (event.key === 'Backspace') {
                    // Allow backspace to erase input
                    currentPlayerInput = currentPlayerInput.slice(0, -1);
                    document.getElementById('input').textContent = currentPlayerInput;
                    document.getElementById('input').style.color = "white";
                } else if (event.key === 'b' || event.key === 'B') {
                    console.log("Manual bullet spawn triggered by key press");
                    spawnTestBullet();
                }
            }
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Call startMusic when the page loads to prepare the audio source
        document.addEventListener('DOMContentLoaded', function() {
            startMusic();
            
            // Set up the enter game button
            document.getElementById('enterGameButton').addEventListener('click', function() {
                // Hide splash overlay
                document.getElementById('splashOverlay').style.display = 'none';
                
                // Show main menu
                document.getElementById('mainMenu').style.display = 'flex';
                
                // Play the audio after user interaction
                audioElement.play().catch(error => console.error("Audio play error:", error));
            });
        });
        
        // Add additional check to show Battle Won at the end of the song
        function checkForBattleWon() {
            if (songCompleted && !currentTargetWord && audioElement.currentTime >= audioElement.duration - 1) {
                // Show "Battle Won" message with direct inline styling
                const getReadyMessage = document.getElementById('get-ready-message');
                getReadyMessage.textContent = "BATTLE WON";
                getReadyMessage.style.display = 'block';
                getReadyMessage.style.color = '#ffdd00';
                getReadyMessage.style.textShadow = '0 0 10px #ffaa00, 0 0 20px #ff8800, 0 0 30px #ff6600';
                getReadyMessage.style.fontSize = '3.5rem';
                getReadyMessage.style.letterSpacing = '2px';
                getReadyMessage.style.animation = 'battle-won-pulse 1.5s infinite';
            }
        }
        
        setInterval(checkForBattleWon, 100);
        
        // Initialize debug overlay when game starts
        function initializeDebugOverlay() {
            // Create debug info element if it doesn't exist
            if (!document.getElementById('debug-info')) {
                const debugInfoElement = document.createElement('div');
                debugInfoElement.id = 'debug-info';
                debugInfoElement.style.position = 'absolute';
                debugInfoElement.style.bottom = '10px';
                debugInfoElement.style.left = '10px';
                debugInfoElement.style.color = '#00ff00';
                debugInfoElement.style.fontFamily = 'monospace';
                debugInfoElement.style.fontSize = '12px';
                debugInfoElement.style.zIndex = '1000';
                debugInfoElement.style.textShadow = '0 0 2px #000'; // Add shadow for visibility
                debugInfoElement.textContent = "Debug: Active | Bullet Hell Mode";
                document.body.appendChild(debugInfoElement);
                
                console.log("Debug overlay initialized");
            }
        }
        
        // Initialize game
        function init() {
            // Create red vignette overlay for hit feedback if it doesn't exist
            if (!document.getElementById('red-vignette')) {
                const redVignette = document.createElement('div');
                redVignette.id = 'red-vignette';
                redVignette.style.position = 'fixed';
                redVignette.style.top = '0';
                redVignette.style.left = '0';
                redVignette.style.width = '100%';
                redVignette.style.height = '100%';
                redVignette.style.backgroundColor = 'rgba(255, 0, 0, 0)';
                redVignette.style.pointerEvents = 'none';
                redVignette.style.transition = 'background-color 0.1s, opacity 0.1s';
                redVignette.style.zIndex = '999';
                redVignette.style.opacity = '0';
                document.body.appendChild(redVignette);
            }
            
            // Initialize debug overlay
            initializeDebugOverlay();
            
            // Initialize enemy movement system after all objects are created
            EnemyMovement.init(enemy);
            
            // Initialize enemy damage system
            EnemyDamage.init();
        }
        
        // When game starts
        function startGame() {
            document.getElementById('mainMenu').style.display = 'none';
            
            inGame = true;
            gameStarted = true;
            gameplayActive = false; // Will be set to true after animation
            
            // Initialize debug overlay
            initializeDebugOverlay();
            
            // Explicitly create health bar UI when the game starts
            if (window.EnemyDamage && typeof EnemyDamage.init === 'function') {
                console.log("Starting game - explicitly initializing enemy damage system");
                EnemyDamage.init();
                
                // Explicitly show the health bar UI with a delay to ensure it appears after animations
                setTimeout(() => {
                    if (typeof EnemyDamage.showUI === 'function') {
                        console.log("Explicitly showing health bar UI");
                        EnemyDamage.showUI();
                    }
                }, 1000);
            } else {
                console.error("Enemy damage system not available!");
            }
            
            animateCharacterEntrance();
        }
        
        // Add keyboard event listeners for arrow key movement controls
        window.addEventListener('keydown', function(event) {
            switch(event.key) {
                case 'ArrowLeft':
                    characterMovement.keys.left = true;
                    break;
                case 'ArrowRight':
                    characterMovement.keys.right = true;
                    break;
                case 'ArrowUp':
                    characterMovement.keys.up = true;
                    // Only jump if not already jumping
                    if (!characterMovement.isJumping && !characterMovement.isCrouching) {
                        characterMovement.yVelocity = characterMovement.jumpSpeed;
                        characterMovement.isJumping = true;
                    }
                    break;
                case 'ArrowDown':
                    characterMovement.keys.down = true;
                    if (!characterMovement.isJumping) {
                        characterMovement.isCrouching = true;
                    }
                    break;
            }
        });
        
        window.addEventListener('keyup', function(event) {
            switch(event.key) {
                case 'ArrowLeft':
                    characterMovement.keys.left = false;
                    break;
                case 'ArrowRight':
                    characterMovement.keys.right = false;
                    break;
                case 'ArrowUp':
                    characterMovement.keys.up = false;
                    break;
                case 'ArrowDown':
                    characterMovement.keys.down = false;
                    characterMovement.isCrouching = false;
                    break;
            }
        });
        
        // Function to start gameplay after animation completes
        function startGameplay() {
            console.log("Starting gameplay after animation");
            gameplayActive = true;
            
            // Show the enemy health bar UI with fade-in effect
            if (window.EnemyDamage && window.EnemyDamage.showUI) {
                console.log("Showing enemy health bar UI");
                window.EnemyDamage.showUI();
            } else {
                console.warn("EnemyDamage.showUI not available");
            }
            
            // Reset the debug overlay if it exists
            const debugInfoElement = document.getElementById('debug-info');
            if (debugInfoElement) {
                debugInfoElement.textContent = "Debug: Gameplay Active";
                debugInfoElement.style.color = '#00ff00';
            }
        }
        
        // Function to animate character entrance
        function animateCharacterEntrance() {
            console.log("Starting character entrance animation");
            
            // Check if characters exist
            if (!character || !enemy) {
                console.error("Character or enemy not defined yet!");
                // Fall back to starting gameplay directly
                startGameplay();
                return;
            }
            
            console.log("Initial positions - Character:", character.position.x, "Enemy:", enemy.position.x);
            
            // Target positions for animation end
            const characterTargetX = -30;
            const enemyTargetX = 30;
            
            // Animation timing variables
            const animationDuration = 2000; // 2 seconds
            const startTime = Date.now();
            let progress = 0;
            
            // Animation function using requestAnimationFrame for smooth animation
            function animate() {
                // Calculate animation progress (0 to 1)
                progress = Math.min((Date.now() - startTime) / animationDuration, 1);
                
                // Use easeOutBack for a slight bounce effect at the end
                // Formula: https://easings.net/#easeOutBack
                const easeOutBack = function(x) {
                    const c1 = 1.70158;
                    const c3 = c1 + 1;
                    return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
                };
                
                // Apply easing
                const easedProgress = easeOutBack(progress);
                
                // Update character position with easing
                character.position.x = -250 + (characterTargetX + 250) * easedProgress;
                
                // Update enemy position with easing
                enemy.position.x = 250 + (enemyTargetX - 250) * easedProgress;
                
                // If animation is complete
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Animation is complete, start gameplay
                    startGameplay();
                }
            }
            
            // Start the animation
            animate();
        }
        
        // Start game after character entrance animation
        document.getElementById('startButton').addEventListener('click', startGame);
        
        // Function to return to the main menu and reset game state
        function returnToMenu() {
            console.log("Returning to main menu");
            
            // Reset game state flags
            gameStarted = false;
            inGame = false;
            gameplayActive = false;
            
            // Move characters off-screen
            if (character) character.position.set(-250, 2, 0);
            if (enemy) enemy.position.set(250, 2, 0);
            
            // Clear all bullets
            if (bullets && bullets.length > 0) {
                bullets.forEach(bullet => {
                    if (bullet && bullet.remove) bullet.remove();
                });
                bullets = [];
            }
            
            // Set gameplay state
            gameplayActive = false; // Will be set to true after animation
            
            // Hide pause menu
            document.getElementById('pauseMenu').style.display = 'none';
            
            // Show main menu
            document.getElementById('mainMenu').style.display = 'flex';
            
            // Hide get ready message
            document.getElementById('get-ready-message').style.display = 'none';
            
            // Pause and reset audio
            audioElement.pause();
            audioElement.currentTime = 0;
            
            // Restart the main menu music
            startMusic();
            audioElement.play().catch(error => console.error("Audio play error:", error));
            
            // Reset game variables
            currentLyricIndex = 0;
            nextLyricIndex = 0;
            nextBeatIndex = 0;
            currentTargetWord = "";
            currentPlayerInput = "";
            targetStartTime = null;
            currentLevel = 0;
            
            // Reset stats
            targetsHit = 0;
            totalTargets = 0;
            correctInputs = 0;
            totalInputs = 0;
            incorrectInputs = 0;
            document.getElementById('targets-hit').textContent = "0";
            document.getElementById('accuracy').textContent = "0%";
            document.getElementById('character-score').textContent = "0";
            document.getElementById('character-level').textContent = "1";
            
            // Clear displays
            document.getElementById('target').textContent = "";
            document.getElementById('input').textContent = "";
        }
        
        // Helper function to store original materials of the character for restoration later
        function captureOriginalMaterials(character) {
            if (!character._originalMaterialsMap) {
                character._originalMaterialsMap = new Map();
                
                // Function to recursively capture materials
                const captureMaterial = (obj) => {
                    // For single materials
                    if (obj.material && !Array.isArray(obj.material)) {
                        // Create a unique identifier for this material
                        const id = obj.uuid;
                        character._originalMaterialsMap.set(id, {
                            material: obj.material.clone(),
                            object: obj
                        });
                    }
                    // For material arrays
                    else if (obj.material && Array.isArray(obj.material)) {
                        const id = obj.uuid;
                        character._originalMaterialsMap.set(id, {
                            materials: obj.material.map(m => m.clone()),
                            object: obj,
                            isArray: true
                        });
                    }
                    
                    // Process children recursively
                    if (obj.children && obj.children.length > 0) {
                        obj.children.forEach(child => captureMaterial(child));
                    }
                };
                
                // Start capturing from the character object
                captureMaterial(character);
                console.log(`Captured ${character._originalMaterialsMap.size} original materials for restoration`);
            }
        }
        
        // Improved function to restore original materials using the captured references
        function restoreFromOriginals(character) {
            if (character._originalMaterialsMap && character._originalMaterialsMap.size > 0) {
                console.log(`Restoring ${character._originalMaterialsMap.size} original materials`);
                
                character._originalMaterialsMap.forEach((data, id) => {
                    const obj = data.object;
                    
                    if (data.isArray && Array.isArray(obj.material)) {
                        // Restore array of materials
                        for (let i = 0; i < obj.material.length && i < data.materials.length; i++) {
                            obj.material[i].copy(data.materials[i]);
                            obj.material[i].needsUpdate = true;
                        }
                    } else if (!data.isArray && obj.material) {
                        // Restore single material
                        obj.material.copy(data.material);
                        obj.material.needsUpdate = true;
                    }
                });
                
                return true;
            }
            
            console.log("No original materials found to restore");
            return false;
        }
        
        // Call captureOriginalMaterials after character creation
        captureOriginalMaterials(character);
        
        // Helper function to completely reset character colors
        function resetCharacterColors(character) {
            // Map of default colors for different types of parts
            const defaultColors = {
                body: new THREE.Color(0xff9fd4),    // Light pink for body
                arm: new THREE.Color(0xff00ff),     // Neon magenta for arms
                leg: new THREE.Color(0xff00ff),     // Neon magenta for legs
                hand: new THREE.Color(0xff00ff),    // Neon magenta for hands
                head: new THREE.Color(0xff9fd4),    // Light pink for head
                weapon: new THREE.Color(0x555555)   // Gray for weapon parts
            };
            
            // Function to identify the type of part and assign proper color
            const identifyPart = (name) => {
                if (!name) return 'body';
                
                const nameLower = name.toLowerCase();
                if (nameLower.includes('arm')) return 'arm';
                if (nameLower.includes('leg')) return 'leg';
                if (nameLower.includes('hand')) return 'hand';
                if (nameLower.includes('head')) return 'head';
                if (nameLower.includes('weapon')) return 'weapon';
                
                // Default to body color
                return 'body';
            };
            
            // Function to reset a material's color based on object name
            const resetMaterial = (material, objName) => {
                if (material && material.color) {
                    // Get part type and corresponding color
                    const partType = identifyPart(objName);
                    const color = defaultColors[partType] || defaultColors.body;
                    
                    // Apply correct default color
                    material.color.copy(color);
                    
                    // Reset emissive if present
                    if (material.emissive) {
                        material.emissive.set(0x000000);
                    }
                    
                    material.needsUpdate = true;
                }
            };
            
            // Function to recursively process an object and its children
            const processObject = (obj) => {
                // Reset material directly attached to this object
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => resetMaterial(mat, obj.name));
                    } else {
                        resetMaterial(obj.material, obj.name);
                    }
                }
                
                // Process all children recursively
                if (obj.children && obj.children.length > 0) {
                    obj.children.forEach(processObject);
                }
            };
            
            // Start from the character object
            processObject(character);
            
            console.log("Character colors completely reset");
        }
        
        // Function to completely reset all character parts to their original colors
        function resetCompleteCharacter(character) {
            console.log("Applying complete character reset");
            
            // Set a flag on the character to indicate it was just reset
            // This will help animation code know not to immediately override our colors
            character.justReset = true;
            
            // First, let's identify all weapon parts by their positions
            const weaponParts = [];
            const cyanParts = [];
            
            // Process each child to identify weapon parts by position
            character.children.forEach((child, index) => {
                if (!child.material) return;
                
                // Weapon parts are generally positioned in front of the character (z > 1.5)
                // and around the center of the character (x values around 3-7)
                if (child.position.z >= 1.5 && child.position.x >= 2 && child.position.x <= 8) {
                    console.log(`Found weapon part at index ${index}:`, child.position);
                    
                    // Cyan parts (core and glow)
                    if ((Math.abs(child.position.x - 3) < 1.5 && child.position.y < 2.5) || // Core
                        child.position.x > 6) { // Glow at end of barrel
                        cyanParts.push(child);
                        
                        // Mark as special parts for animation
                        if (Math.abs(child.position.x - 3) < 1.5) {
                            child.isWeaponCore = true;
                        } else {
                            child.isWeaponGlow = true;
                        }
                    } 
                    // Gray weapon parts (body, barrel, etc)
                    else {
                        weaponParts.push(child);
                    }
                }
            });
            
            console.log(`Identified ${weaponParts.length} weapon parts and ${cyanParts.length} cyan parts`);
            
            // Reset weapon parts to gray shades
            weaponParts.forEach((part, i) => {
                if (!part.material) return;
                
                // Determine the gray shade based on the part's position
                let color;
                
                // Main body - medium gray
                if (Math.abs(part.position.y - 2) < 0.5 && part.position.x < 5) {
                    color = 0x555555; // Medium gray
                }
                // Top rail - very dark gray (higher Y position)
                else if (part.position.y > 2.3) {
                    color = 0x222222; // Very dark gray
                }
                // Grip or barrel - darker gray
                else {
                    color = 0x333333; // Darker gray
                }
                
                console.log(`  Setting weapon part ${i} at position (${part.position.x.toFixed(1)}, ${part.position.y.toFixed(1)}, ${part.position.z.toFixed(1)}) to color ${color.toString(16)}`);
                
                // Apply the color
                if (Array.isArray(part.material)) {
                    part.material.forEach(mat => {
                        if (mat && mat.color) {
                            mat.color.setHex(color);
                            if (mat.emissive) mat.emissive.set(0x000000);
                            mat.needsUpdate = true;
                        }
                    });
                } else if (part.material && part.material.color) {
                    part.material.color.setHex(color);
                    if (part.material.emissive) part.material.emissive.set(0x000000);
                    part.material.needsUpdate = true;
                }
            });
            
            // Reset cyan parts
            cyanParts.forEach((part, i) => {
                if (!part.material) return;
                
                console.log(`  Setting cyan part ${i} at position (${part.position.x.toFixed(1)}, ${part.position.y.toFixed(1)}, ${part.position.z.toFixed(1)}) to cyan`);
                
                // Apply cyan color
                if (Array.isArray(part.material)) {
                    part.material.forEach(mat => {
                        if (mat && mat.color) {
                            mat.color.setHex(0x00ffff); // Cyan
                            if (mat.emissive) mat.emissive.set(0x000000);
                            mat.needsUpdate = true;
                        }
                    });
                } else if (part.material && part.material.color) {
                    part.material.color.setHex(0x00ffff); // Cyan
                    if (part.material.emissive) part.material.emissive.set(0x000000);
                    part.material.needsUpdate = true;
                }
            });
            
            // Apply standard colors to non-weapon parts
            character.children.forEach((child, index) => {
                // Skip weapon parts we already handled
                if (weaponParts.includes(child) || cyanParts.includes(child)) {
                    return;
                }
                
                if (!child.material) return;
                
                // Determine the correct color
                let color;
                
                // Visor is cyan (usually index 2)
                if (index === 2) {
                    color = 0x00ffff; // Cyan
                }
                // All other body parts should be magenta
                else {
                    color = 0xff00ff; // Neon magenta
                }
                
                // Apply the color
                if (Array.isArray(child.material)) {
                    child.material.forEach(mat => {
                        if (mat && mat.color) {
                            mat.color.setHex(color);
                            if (mat.emissive) mat.emissive.set(0x000000);
                            mat.needsUpdate = true;
                        }
                    });
                } else if (child.material && child.material.color) {
                    child.material.color.setHex(color);
                    if (child.material.emissive) child.material.emissive.set(0x000000);
                    child.material.needsUpdate = true;
                }
            });
            
            // Reset the flag after a short delay to allow normal animations to resume
            setTimeout(() => {
                character.justReset = false;
            }, 25);
            
            // Force renderer update
            console.log("Character colors reset complete");
        }
    </script>
    
    <!-- Bullet collision fix script -->
    <script src="bullet_collision_fix.js"></script>
    <!-- Bullet origin fix script -->
    <script src="bullet_origin_fix.js"></script>
    
    <!-- Vibe Jam 2025 link -->
    <a target="_blank" href="https://jam.pieter.com" style="font-family: 'system-ui', sans-serif; position: fixed; bottom: -1px; right: -1px; padding: 7px; font-size: 14px; font-weight: bold; background: #fff; color: #000; text-decoration: none; z-index: 10; border-top-left-radius: 12px; z-index: 10000; border: 1px solid #fff;"> Vibe Jam 2025</a>
</body>
</html>
